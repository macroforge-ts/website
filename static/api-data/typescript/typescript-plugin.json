{
  "name": "@macroforge/typescript-plugin",
  "kind": "typescript_package",
  "version": "0.1.39",
  "description": "TypeScript language service plugin that augments classes decorated with @derive to include macro-generated methods.",
  "overview": "TypeScript Language Service Plugin for Macroforge\n\nThis plugin integrates Macroforge's compile-time macro expansion with TypeScript's\nLanguage Service to provide seamless IDE support for macro-decorated classes.\n\n## Architecture Overview\n\nThe plugin operates by intercepting TypeScript's Language Service methods and\ntransforming source code on-the-fly:\n\n1. **Macro Expansion**: When TypeScript requests a file's content via `getScriptSnapshot`,\nthis plugin intercepts the call and returns the macro-expanded version instead.\n\n2. **Position Mapping**: Since expanded code has different positions than the original,\nthe plugin maintains a {@link PositionMapper} for each file to translate positions\nbetween original and expanded coordinates.\n\n3. **Virtual .d.ts Files**: For each macro-containing file, the plugin generates a\ncompanion `.macroforge.d.ts` file containing type declarations for generated methods.\n\n## Supported File Types\n\n- `.ts` - TypeScript files\n- `.tsx` - TypeScript JSX files\n- `.svelte` - Svelte components (with `<script lang=\"ts\">`)\n\n## Hook Categories\n\nThe plugin hooks into three categories of Language Service methods:\n\n- **Host-level hooks**: Control what TypeScript \"sees\" (`getScriptSnapshot`, `fileExists`, etc.)\n- **Diagnostic hooks**: Map error positions back to original source (`getSemanticDiagnostics`)\n- **Navigation hooks**: Handle go-to-definition, references, completions, etc.\n\n@example\n```typescript\n{\n\"compilerOptions\": {\n\"plugins\": [{ \"name\": \"@macroforge/typescript-plugin\" }]\n}\n}\n```",
  "items": [
    {
      "name": "macroManifestCache",
      "kind": "variable",
      "signature": "import type ts from \"typescript/lib/tsserverlibrary\";\nimport type { ExpandResult, MacroManifest, MacroManifestEntry, DecoratorManifestEntry } from \"macroforge\";\nimport { NativePlugin, PositionMapper, __macroforgeGetManifest } from \"macroforge\";\nimport path from \"path\";\nimport fs from \"fs\";\n\n/**\n * Cached macro manifest for hover information.\n *\n * This cache stores macro and decorator metadata loaded from the native Macroforge\n * plugin. The cache is populated on first access and persists for the lifetime of\n * the language server process.\n *\n * @internal\n */\nlet macroManifestCache",
      "description": "",
      "returns": null,
      "examples": [
        "```typescript\n{\n\"compilerOptions\": {\n\"plugins\": [{ \"name\": \"@macroforge/typescript-plugin\" }]\n}\n}\n```"
      ],
      "remarks": null,
      "see": [
        "{@link init} - The main plugin factory function",
        "{@link PositionMapper} - Position mapping between original and expanded code"
      ],
      "deprecated": null
    },
    {
      "name": "getMacroManifest",
      "kind": "function",
      "signature": "macros: Map<string, MacroManifestEntry>;\n  /** Map of lowercase decorator export name to its manifest entry */\n  decorators: Map<string, DecoratorManifestEntry>;\n} | null = null;\n\n/**\n * Retrieves the cached macro manifest, loading it if necessary.\n *\n * The manifest contains metadata about all available macros and decorators,\n * including their names, descriptions, and documentation. This information\n * is used to provide hover tooltips in the IDE.\n *\n * @returns The macro manifest with Maps for quick lookup by name, or `null` if\n *          the manifest could not be loaded (e.g., native plugin not available)\n *\n * @remarks\n * The manifest is cached after first load. Macro names and decorator exports\n * are stored in lowercase for case-insensitive lookups.\n *\n * @example\n * ```typescript\n * const manifest = getMacroManifest();\n * if (manifest)",
      "description": "",
      "returns": null,
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "parseMacroImportComments",
      "kind": "function",
      "signature": "function parseMacroImportComments(text: string): Map<string, string>",
      "description": "Parses macro import comments to extract macro name to module path mappings.\nMacroforge supports importing external macros using a special JSDoc comment syntax:\n`/** import macro {MacroName, Another} from \"@scope/package\"; *​/`",
      "params": [
        {
          "name": "text",
          "type": "",
          "description": "The source text to search for import comments"
        }
      ],
      "returns": {
        "type": "",
        "description": "A Map of macro name to module path"
      },
      "examples": [
        "```typescript\nconst text = `/** import macro {Gigaform, CustomMacro} from \"@playground/macro\"; *​/`;\nparseMacroImportComments(text);\n```"
      ],
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "externalManifestCache",
      "kind": "variable",
      "signature": "const externalManifestCache",
      "description": "Cache for external macro package manifests.\nMaps package path to its manifest (or null if failed to load).",
      "returns": null,
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "getExternalManifest",
      "kind": "function",
      "signature": "function getExternalManifest(modulePath: string): MacroManifest | null",
      "description": "Attempts to load the manifest from an external macro package.\nExternal macro packages (like `@playground/macro`) export their own\n`__macroforgeGetManifest()` function that provides macro metadata\nincluding descriptions.",
      "params": [
        {
          "name": "modulePath",
          "type": "",
          "description": "The package path (e.g., \"@playground/macro\")"
        }
      ],
      "returns": {
        "type": "",
        "description": "The macro manifest, or null if loading failed"
      },
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "getExternalMacroInfo",
      "kind": "function",
      "signature": "function getExternalMacroInfo(\n  macroName: string,\n  modulePath: string,\n): MacroManifestEntry | null",
      "description": "Looks up macro info from an external package manifest.",
      "params": [
        {
          "name": "macroName",
          "type": "",
          "description": "The macro name to look up"
        },
        {
          "name": "modulePath",
          "type": "",
          "description": "The package path"
        }
      ],
      "returns": {
        "type": "",
        "description": "The macro manifest entry, or null if not found"
      },
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "getExternalDecoratorInfo",
      "kind": "function",
      "signature": "function getExternalDecoratorInfo(\n  decoratorName: string,\n  modulePath: string,\n): DecoratorManifestEntry | null",
      "description": "Looks up decorator info from an external package manifest.",
      "params": [
        {
          "name": "decoratorName",
          "type": "",
          "description": "The decorator name to look up"
        },
        {
          "name": "modulePath",
          "type": "",
          "description": "The package path"
        }
      ],
      "returns": {
        "type": "",
        "description": "The decorator manifest entry, or null if not found"
      },
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "findDeriveAtPosition",
      "kind": "function",
      "signature": "function findDeriveAtPosition(\n  text: string,\n  position: number,\n):",
      "description": "Finds a macro name within `@derive(...)` decorators at a given cursor position.\nThis function parses JSDoc comments looking for `@derive` directives and determines\nif the cursor position falls within a specific macro name in the argument list.",
      "params": [
        {
          "name": "text",
          "type": "",
          "description": "The source text to search"
        },
        {
          "name": "position",
          "type": "",
          "description": "The cursor position as a 0-indexed character offset from the start of the file"
        }
      ],
      "returns": {
        "type": "",
        "description": "An object containing the macro name and its character span, or `null` if the\nposition is not within a macro name"
      },
      "examples": [
        "```typescript\nfindDeriveAtPosition(text, 14);\nfindDeriveAtPosition(text, 20);\nfindDeriveAtPosition(text, 5);\n```"
      ],
      "remarks": "The function uses the regex `/@derive\\s*\\(\\s*([^)]+)\\s*\\)/gi` to find all `@derive`\ndecorators, then parses the comma-separated macro names within the parentheses.\nPosition calculation accounts for:\n- Whitespace between `@derive` and the opening parenthesis\n- Whitespace around macro names in the argument list\n- Multiple macros separated by commas",
      "deprecated": null
    },
    {
      "name": "findDeriveKeywordAtPosition",
      "kind": "function",
      "signature": "function findDeriveKeywordAtPosition(\n  text: string,\n  position: number,\n):",
      "description": "Finds the `@derive` keyword at a given cursor position.\nThis matches the literal \"@derive\" text before the opening parenthesis,\nallowing hover documentation on the directive keyword itself.",
      "params": [
        {
          "name": "text",
          "type": "",
          "description": "The source text to search"
        },
        {
          "name": "position",
          "type": "",
          "description": "The cursor position as a 0-indexed character offset"
        }
      ],
      "returns": {
        "type": "",
        "description": "An object with start/end positions, or `null` if not on @derive keyword"
      },
      "examples": [
        "```typescript\nfindDeriveKeywordAtPosition(text, 5);\nfindDeriveKeywordAtPosition(text, 12);\n```"
      ],
      "remarks": null,
      "see": [
        "{@link findDeriveAtPosition} - For macro names inside @derive()"
      ],
      "deprecated": null
    },
    {
      "name": "findDecoratorAtPosition",
      "kind": "function",
      "signature": "function findDecoratorAtPosition(\n  text: string,\n  position: number,\n):",
      "description": "Finds a field decorator (like `@serde` or `@debug`) at a given cursor position.\nThis function searches for decorator patterns (`@name`) in the source text and\ndetermines if the cursor falls within one. It's used to provide hover information\nfor Macroforge field decorators.",
      "params": [
        {
          "name": "text",
          "type": "",
          "description": "The source text to search"
        },
        {
          "name": "position",
          "type": "",
          "description": "The cursor position as a 0-indexed character offset"
        }
      ],
      "returns": {
        "type": "",
        "description": "An object containing the decorator name (without `@`) and its span\n(including the `@` symbol), or `null` if not found"
      },
      "examples": [
        "```typescript\nfindDecoratorAtPosition(text, 14);\nfindDecoratorAtPosition(text, 5);\n```"
      ],
      "remarks": "This function explicitly skips `@derive` decorators that appear within JSDoc comments,\nas those are handled by {@link findDeriveAtPosition} instead. The detection works by\nchecking if the match is between an unclosed JSDoc start and end markers.\nThe span returned includes the `@` symbol, so for `@serde`:\n- `start` points to the `@` character\n- `end` points to the character after the last letter of the name",
      "see": [
        "{@link findDeriveAtPosition} - For `@derive` decorators in JSDoc comments"
      ],
      "deprecated": null
    },
    {
      "name": "findEnclosingDeriveContext",
      "kind": "function",
      "signature": "\");\n        if (lastCommentStart > lastCommentEnd)",
      "description": "const lastCommentEnd = beforeMatch.lastIndexOf(\"*/",
      "returns": null,
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "getMacroHoverInfo",
      "kind": "function",
      "signature": "function getMacroHoverInfo(\n  text: string,\n  position: number,\n  tsModule: typeof ts,\n): ts.QuickInfo | null",
      "description": "Generates hover information (QuickInfo) for macros and decorators at a cursor position.\nThis function provides IDE hover tooltips for Macroforge-specific syntax:\n- The `@derive` keyword itself\n- Macro names within `@derive(...)` JSDoc decorators (both built-in and external)\n- Field decorators like `@serde`, `@debug`, and custom decorators from external macros",
      "params": [
        {
          "name": "text",
          "type": "",
          "description": "The source text to analyze"
        },
        {
          "name": "position",
          "type": "",
          "description": "The cursor position as a 0-indexed character offset"
        },
        {
          "name": "tsModule",
          "type": "",
          "description": "The TypeScript module reference (for creating QuickInfo structures)"
        }
      ],
      "returns": {
        "type": "",
        "description": "A TypeScript QuickInfo object suitable for hover display, or `null` if the\nposition is not on a recognized macro or decorator"
      },
      "examples": [
        "```typescript\nconst info = getMacroHoverInfo(text, 4, ts);\nconst info = getMacroHoverInfo(text, 14, ts);\nconst info = getMacroHoverInfo(text, 14, ts);\nconst info = getMacroHoverInfo(text, 5, ts);\nconst info = getMacroHoverInfo(text, 5, ts);\n```"
      ],
      "remarks": "The function checks positions in the following order:\n1. Check if cursor is on the `@derive` keyword via {@link findDeriveKeywordAtPosition}\n2. Check if cursor is on a macro name within `@derive(...)` via {@link findDeriveAtPosition}\n- First checks built-in manifest via {@link getMacroManifest}\n- Then checks external macro imports via {@link parseMacroImportComments}\n- Falls back to generic hover for unknown macros\n3. Check if cursor is on a field decorator via {@link findDecoratorAtPosition}\n- First checks built-in manifest (macros and decorators)\n- Then checks external package manifests via {@link getExternalDecoratorInfo}\n- Falls back to generic hover showing enclosing derive context\nFor external macros (imported via `/** import macro {Name} from \"package\"; * /`),\nthe function attempts to load the external package's manifest to retrieve\ndescriptions and documentation. See {@link getExternalMacroInfo}.\nThe returned QuickInfo includes:\n- `kind`: `keyword` for @derive, `functionElement` for macros/decorators\n- `textSpan`: The highlighted range in the editor\n- `displayParts`: The formatted display text (e.g., \"@derive(Debug)\")\n- `documentation`: The macro/decorator description from the manifest",
      "see": [
        "{@link findDeriveKeywordAtPosition} - Locates the @derive keyword",
        "{@link findDeriveAtPosition} - Locates macro names in @derive decorators",
        "{@link findDecoratorAtPosition} - Locates field decorators",
        "{@link findEnclosingDeriveContext} - Finds macros that apply to a position",
        "{@link getMacroManifest} - Provides built-in macro/decorator metadata",
        "{@link getExternalMacroInfo} - Provides external macro metadata",
        "{@link getExternalDecoratorInfo} - Provides external decorator metadata"
      ],
      "deprecated": null
    },
    {
      "name": "FILE_EXTENSIONS",
      "kind": "variable",
      "signature": "`\\n\\n\" +\n            \"**Built-in macros:** Debug, Clone, Default, Hash, PartialEq, PartialOrd, Ord, Serialize, Deserialize\\n\\n\" +\n            \"External macros can be imported using:\\n\" +\n            '`/** import macro {Name} from \"package\"; */`',\n          kind: \"text\",\n        },\n      ],\n    };\n  }\n\n  // Parse external macro imports for later use\n  const externalMacros = parseMacroImportComments(text);\n\n  // 2. Check for @derive(MacroName) in JSDoc comments\n  const deriveMatch = findDeriveAtPosition(text, position);\n  if (deriveMatch) {\n    // 2a. Check built-in manifest\n    const macroInfo = manifest?.macros.get(deriveMatch.macroName.toLowerCase());\n    if (macroInfo) {\n      return {\n        kind: tsModule.ScriptElementKind.functionElement,\n        kindModifiers: \"\",\n        textSpan: {\n          start: deriveMatch.start,\n          length: deriveMatch.end - deriveMatch.start,\n        },\n        displayParts: [\n          { text: \"@derive(\", kind: \"punctuation\" },\n          { text: macroInfo.name, kind: \"functionName\" },\n          { text: \")\", kind: \"punctuation\" },\n        ],\n        documentation: macroInfo.description\n          ? [{ text: macroInfo.description, kind: \"text\" }]\n          : [],\n      };\n    }\n\n    // 2b. Check external macro imports\n    const modulePath = externalMacros.get(deriveMatch.macroName);\n    if (modulePath) {\n      // Try to get detailed info from the external package manifest\n      const externalMacroInfo = getExternalMacroInfo(\n        deriveMatch.macroName,\n        modulePath,\n      );\n      const description = externalMacroInfo?.description\n        ? externalMacroInfo.description\n        : \"This macro is loaded from an external package at compile time.\";\n\n      return {\n        kind: tsModule.ScriptElementKind.functionElement,\n        kindModifiers: \"external\",\n        textSpan: {\n          start: deriveMatch.start,\n          length: deriveMatch.end - deriveMatch.start,\n        },\n        displayParts: [\n          { text: \"@derive(\", kind: \"punctuation\" },\n          { text: externalMacroInfo?.name ?? deriveMatch.macroName, kind: \"functionName\" },\n          { text: \")\", kind: \"punctuation\" },\n        ],\n        documentation: [\n          {\n            text: `**External macro** from \\`${modulePath}\\`\\n\\n${description}`,\n            kind: \"text\",\n          },\n        ],\n      };\n    }\n\n    // 2c. Fallback for unknown/unrecognized macros\n    return {\n      kind: tsModule.ScriptElementKind.functionElement,\n      kindModifiers: \"\",\n      textSpan: {\n        start: deriveMatch.start,\n        length: deriveMatch.end - deriveMatch.start,\n      },\n      displayParts: [\n        { text: \"@derive(\", kind: \"punctuation\" },\n        { text: deriveMatch.macroName, kind: \"functionName\" },\n        { text: \")\", kind: \"punctuation\" },\n      ],\n      documentation: [\n        {\n          text:\n            `**Macro:** ${deriveMatch.macroName}\\n\\n` +\n            \"This macro is not in the built-in manifest. If it's a custom macro, \" +\n            \"ensure it's imported using:\\n\\n\" +\n            `\\`/** import macro {${deriveMatch.macroName}} from \"your-package\"; */\\``,\n          kind: \"text\",\n        },\n      ],\n    };\n  }\n\n  // 3. Check for @decorator patterns\n  const decoratorMatch = findDecoratorAtPosition(text, position);\n  if (decoratorMatch) {\n    // 3a. Check if it's a built-in macro name\n    const macroInfo = manifest?.macros.get(decoratorMatch.name.toLowerCase());\n    if (macroInfo) {\n      return {\n        kind: tsModule.ScriptElementKind.functionElement,\n        kindModifiers: \"\",\n        textSpan: {\n          start: decoratorMatch.start,\n          length: decoratorMatch.end - decoratorMatch.start,\n        },\n        displayParts: [\n          { text: \"@\", kind: \"punctuation\" },\n          { text: macroInfo.name, kind: \"functionName\" },\n        ],\n        documentation: macroInfo.description\n          ? [{ text: macroInfo.description, kind: \"text\" }]\n          : [],\n      };\n    }\n\n    // 3b. Check if it's a built-in decorator\n    const decoratorInfo = manifest?.decorators.get(\n      decoratorMatch.name.toLowerCase(),\n    );\n    if (decoratorInfo && decoratorInfo.docs) {\n      return {\n        kind: tsModule.ScriptElementKind.functionElement,\n        kindModifiers: \"\",\n        textSpan: {\n          start: decoratorMatch.start,\n          length: decoratorMatch.end - decoratorMatch.start,\n        },\n        displayParts: [\n          { text: \"@\", kind: \"punctuation\" },\n          { text: decoratorInfo.export, kind: \"functionName\" },\n        ],\n        documentation: [{ text: decoratorInfo.docs, kind: \"text\" }],\n      };\n    }\n\n    // 3c. Check if this decorator is in a macro context (for external/custom decorators)\n    const enclosingMacros = findEnclosingDeriveContext(\n      text,\n      decoratorMatch.start,\n    );\n    if (enclosingMacros && enclosingMacros.length > 0) {\n      // Find which external macro might define this decorator\n      const likelySourceMacro = enclosingMacros.find((m) =>\n        externalMacros.has(m),\n      );\n\n      if (likelySourceMacro) {\n        const modulePath = externalMacros.get(likelySourceMacro);\n        // Try to get detailed decorator info from the external package\n        const externalDecoratorInfo = modulePath\n          ? getExternalDecoratorInfo(decoratorMatch.name, modulePath)\n          : null;\n        const description = externalDecoratorInfo?.docs\n          ? externalDecoratorInfo.docs\n          : \"This decorator configures field-level behavior for the macro.\";\n\n        return {\n          kind: tsModule.ScriptElementKind.functionElement,\n          kindModifiers: \"external\",\n          textSpan: {\n            start: decoratorMatch.start,\n            length: decoratorMatch.end - decoratorMatch.start,\n          },\n          displayParts: [\n            { text: \"@\", kind: \"punctuation\" },\n            { text: externalDecoratorInfo?.export ?? decoratorMatch.name, kind: \"functionName\" },\n          ],\n          documentation: [\n            {\n              text:\n                `**Field decorator** from \\`${likelySourceMacro}\\` macro (\\`${modulePath}\\`)\\n\\n` +\n                description,\n              kind: \"text\",\n            },\n          ],\n        };\n      }\n\n      // Fallback: Generic decorator in macro context\n      return {\n        kind: tsModule.ScriptElementKind.functionElement,\n        kindModifiers: \"\",\n        textSpan: {\n          start: decoratorMatch.start,\n          length: decoratorMatch.end - decoratorMatch.start,\n        },\n        displayParts: [\n          { text: \"@\", kind: \"punctuation\" },\n          { text: decoratorMatch.name, kind: \"functionName\" },\n        ],\n        documentation: [\n          {\n            text:\n              `**Field decorator:** ${decoratorMatch.name}\\n\\n` +\n              `Used with @derive(${enclosingMacros.join(\", \")}).\\n` +\n              \"This decorator configures field-level behavior for the applied macros.\",\n            kind: \"text\",\n          },\n        ],\n      };\n    }\n  }\n\n  return null;\n}\n\n/**\n * File extensions that the plugin will process for macro expansion.\n * @internal\n */\nconst FILE_EXTENSIONS",
      "description": "",
      "returns": null,
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "shouldProcess",
      "kind": "function",
      "signature": "function shouldProcess(fileName: string)",
      "description": "Determines whether a file should be processed for macro expansion.\nThis is a gatekeeper function that filters out files that should not\ngo through macro expansion, either because they're in excluded directories\nor have unsupported file types.",
      "params": [
        {
          "name": "fileName",
          "type": "",
          "description": "The absolute path to the file"
        }
      ],
      "returns": {
        "type": "",
        "description": "`true` if the file should be processed, `false` otherwise"
      },
      "examples": [
        "```typescript\nshouldProcess('/project/src/User.ts');        // => true\nshouldProcess('/project/src/App.svelte');     // => true\nshouldProcess('/project/node_modules/...');   // => false\nshouldProcess('/project/User.macroforge.d.ts'); // => false\n```"
      ],
      "remarks": "Files are excluded if they:\n- Are in `node_modules` (dependencies should not be processed)\n- Are in the `.macroforge` cache directory\n- End with `.macroforge.d.ts` (generated type declaration files)\n- Don't have a supported extension (`.ts`, `.tsx`, `.svelte`)",
      "deprecated": null
    },
    {
      "name": "hasMacroDirectives",
      "kind": "function",
      "signature": "function hasMacroDirectives(text: string)",
      "description": "Performs a quick check to determine if a file contains any macro-related directives.\nThis is a fast pre-filter to avoid expensive macro expansion on files that\ndon't contain any macros. It uses simple string/regex checks rather than\nfull parsing for performance.",
      "params": [
        {
          "name": "text",
          "type": "",
          "description": "The source text to check"
        }
      ],
      "returns": {
        "type": "",
        "description": "`true` if the file likely contains macro directives, `false` otherwise"
      },
      "examples": [
        "```typescript\nhasMacroDirectives('/** @derive(Debug) * /');  // => true\nhasMacroDirectives('@Debug class User {}');    // => true (contains @derive substring? no, but @Debug yes)\nhasMacroDirectives('class User {}');           // => false\n```"
      ],
      "remarks": "The function checks for the following patterns:\n- `@derive` anywhere in the text (catches both JSDoc and decorator usage)\n- `/** @derive(` pattern (JSDoc macro declaration)\n- `/** import macro` pattern (inline macro import syntax)\nThis is intentionally permissive - it's better to have false positives\n(which just result in unnecessary expansion attempts) than false negatives\n(which would break macro functionality).",
      "deprecated": null
    },
    {
      "name": "MacroConfig",
      "kind": "type",
      "signature": "type MacroConfig",
      "description": "Configuration options loaded from `macroforge.json`.",
      "returns": null,
      "remarks": "This configuration affects how macros are expanded and what artifacts\nare preserved in the output.",
      "deprecated": null
    },
    {
      "name": "loadMacroConfig",
      "kind": "function",
      "signature": "keepDecorators: boolean;\n};\n\n/**\n * Loads Macroforge configuration by searching for `macroforge.json` up the directory tree.\n *\n * Starting from the given directory, this function walks up the filesystem hierarchy\n * looking for a `macroforge.json` configuration file. The first one found is parsed\n * and its settings are returned.\n *\n * @param startDir - The directory to start searching from (typically the project root)\n * @returns The parsed configuration, or default values if no config file is found\n *\n * @remarks\n * The search stops when:\n * - A `macroforge.json` file is found and successfully parsed\n * - The filesystem root is reached\n * - A parse error occurs (falls back to defaults)\n *\n * This allows monorepo setups where a root `macroforge.json` can configure\n * all packages, while individual packages can override with their own config.\n *\n * @example\n * ```typescript\n * // With /project/macroforge.json containing:",
      "description": "Whether to preserve decorator syntax in the expanded output.\nWhen `true`, decorators like `@serde` are kept in the expanded code\n(useful for runtime decorator processing). When `false`, they are\nstripped during expansion.",
      "returns": null,
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "init",
      "kind": "function",
      "signature": "function init(modules:",
      "description": "Main plugin factory function conforming to the TypeScript Language Service Plugin API.\nThis function is called by TypeScript when the plugin is loaded. It receives the\nTypeScript module reference and returns an object with a `create` function that\nTypeScript will call to instantiate the plugin for each project.",
      "params": [
        {
          "name": "modules",
          "type": "",
          "description": "Object containing the TypeScript module reference"
        },
        {
          "name": "modules",
          "type": "",
          "description": ".typescript - The TypeScript module (`typescript/lib/tsserverlibrary`)"
        }
      ],
      "returns": {
        "type": "",
        "description": "An object with a `create` method that TypeScript calls to instantiate the plugin"
      },
      "examples": [
        "```typescript\nconst plugin = require('@macroforge/typescript-plugin');\nconst { create } = plugin(modules);\nconst languageService = create(pluginCreateInfo);\n```"
      ],
      "remarks": "The plugin follows the standard TypeScript Language Service Plugin pattern:\n1. `init()` is called once when the plugin is loaded\n2. `create()` is called for each TypeScript project that uses the plugin\n3. The returned LanguageService has hooked methods that intercept TypeScript operations\n## Plugin Architecture\nThe plugin maintains several internal data structures:\n- **virtualDtsFiles**: Stores generated `.macroforge.d.ts` type declaration files\n- **snapshotCache**: Caches expanded file snapshots for stable identity across TS requests\n- **processingFiles**: Guards against reentrancy during macro expansion\n- **nativePlugin**: Rust-backed expansion engine (handles actual macro processing)\n## Hooked Methods\nThe plugin hooks into ~22 TypeScript Language Service methods to provide seamless\nIDE support. These fall into three categories:\n1. **Host-level hooks** (what TS \"sees\"):\n- `getScriptSnapshot` - Returns expanded code instead of original\n- `getScriptVersion` - Provides versions for virtual .d.ts files\n- `getScriptFileNames` - Includes virtual .d.ts in project file list\n- `fileExists` - Resolves virtual .d.ts files\n2. **Diagnostic hooks** (error reporting):\n- `getSemanticDiagnostics` - Maps error positions, adds macro errors\n- `getSyntacticDiagnostics` - Maps syntax error positions\n3. **Navigation hooks** (IDE features):\n- `getQuickInfoAtPosition` - Hover information\n- `getCompletionsAtPosition` - IntelliSense completions\n- `getDefinitionAtPosition` - Go to definition\n- `findReferences` - Find all references\n- ... and many more",
      "see": [
        "{@link shouldProcess} - File filtering logic",
        "{@link processFile} - Main macro expansion entry point"
      ],
      "deprecated": null
    },
    {
      "name": "create",
      "kind": "function",
      "signature": "function create(info: ts.server.PluginCreateInfo)",
      "description": "Creates the plugin instance for a TypeScript project.\nThis function is called by TypeScript for each project that has the plugin configured.\nIt sets up all the necessary hooks and state, then returns the modified LanguageService.",
      "params": [
        {
          "name": "info",
          "type": "",
          "description": "Plugin creation info provided by TypeScript, containing:\n- `project`: The TypeScript project instance\n- `languageService`: The base LanguageService to augment\n- `languageServiceHost`: The host providing file system access\n- `config`: Plugin configuration from tsconfig.json"
        }
      ],
      "returns": {
        "type": "",
        "description": "The augmented LanguageService with macro support"
      },
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "virtualDtsFiles",
      "kind": "variable",
      "signature": "const virtualDtsFiles",
      "description": "Map storing generated virtual `.macroforge.d.ts` files.\nFor each source file containing macros, we generate a companion `.d.ts` file\nwith type declarations for the generated methods. These virtual files are\nserved to TypeScript as if they existed on disk.",
      "returns": null,
      "remarks": "Key: Virtual file path (e.g., `/project/src/User.ts.macroforge.d.ts`)\nValue: ScriptSnapshot containing the generated type declarations",
      "deprecated": null
    },
    {
      "name": "snapshotCache",
      "kind": "variable",
      "signature": "const snapshotCache",
      "description": "Cache for processed file snapshots to ensure identity stability.\nTypeScript's incremental compiler relies on snapshot identity to detect changes.\nBy caching snapshots keyed by version, we ensure the same snapshot object is\nreturned for unchanged files, preventing unnecessary recompilation.",
      "returns": null,
      "remarks": "Key: Source file path\nValue: Object containing the file version and its expanded snapshot",
      "deprecated": null
    },
    {
      "name": "processingFiles",
      "kind": "variable",
      "signature": "const processingFiles",
      "description": "Set of files currently being processed for macro expansion.\nThis guards against reentrancy - if TypeScript requests a file while we're\nalready processing it (e.g., due to import resolution during expansion),\nwe return the original content to prevent infinite loops.",
      "returns": null,
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "nativePlugin",
      "kind": "variable",
      "signature": "const nativePlugin",
      "description": "Native Rust-backed plugin instance for macro expansion.\nThe NativePlugin handles the actual macro expansion logic, caching, and\nsource mapping. It's implemented in Rust for performance and is accessed\nvia N-API bindings.",
      "returns": null,
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "getCurrentDirectory",
      "kind": "variable",
      "signature": "const getCurrentDirectory",
      "description": "Gets the current working directory for the project.\nTries multiple sources in order of preference:\n1. Project's getCurrentDirectory method\n2. Language service host's getCurrentDirectory method\n3. Falls back to process.cwd()",
      "returns": {
        "type": "",
        "description": "The project's root directory path"
      },
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "log",
      "kind": "variable",
      "signature": "const log",
      "description": "Logs a message to multiple destinations for debugging.\nMessages are sent to:\n1. The native Rust plugin (for unified logging)\n2. TypeScript's project service logger (visible in tsserver logs)\n3. stderr (for development debugging)",
      "params": [
        {
          "name": "msg",
          "type": "",
          "description": "The message to log (will be prefixed with timestamp and [macroforge])"
        }
      ],
      "returns": null,
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "ensureVirtualDtsRegistered",
      "kind": "variable",
      "signature": "const ensureVirtualDtsRegistered",
      "description": "Registers a virtual `.macroforge.d.ts` file with TypeScript's project service.\nThis makes TypeScript aware of our generated type declaration files so they\ncan be resolved during import resolution and type checking.",
      "params": [
        {
          "name": "fileName",
          "type": "",
          "description": "The path to the virtual .d.ts file to register"
        }
      ],
      "returns": null,
      "remarks": "Uses internal TypeScript APIs (`getOrCreateScriptInfoNotOpenedByClient`)\nwhich may change between TypeScript versions. The function gracefully\nhandles missing APIs.",
      "deprecated": null
    },
    {
      "name": "cleanupVirtualDts",
      "kind": "variable",
      "signature": "const cleanupVirtualDts",
      "description": "Removes a virtual `.macroforge.d.ts` file from TypeScript's project service.\nCalled when a source file no longer generates types (e.g., macros removed)\nto clean up stale virtual files and prevent memory leaks.",
      "params": [
        {
          "name": "fileName",
          "type": "",
          "description": "The path to the virtual .d.ts file to remove"
        }
      ],
      "returns": null,
      "remarks": "The cleanup is conservative - it only deletes the ScriptInfo if:\n1. The file is not open in an editor\n2. The file is not attached to any other projects",
      "deprecated": null
    },
    {
      "name": "projectService",
      "kind": "variable",
      "signature": "const projectService",
      "description": "Override projectService.setDocument to handle virtual files safely.\nThis guards against TypeScript crashes when it tries to cache source files\nfor virtual .d.ts files that don't have full ScriptInfo backing.",
      "returns": null,
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "processFile",
      "kind": "function",
      "signature": "function processFile(\n      fileName: string,\n      content: string,\n      version: string,\n    ):",
      "description": "Processes a file through macro expansion via the native Rust plugin.\nThis is the main entry point for macro expansion. It delegates to the native\nRust plugin for the actual transformation and handles virtual .d.ts file\nmanagement for generated type declarations.",
      "params": [
        {
          "name": "fileName",
          "type": "",
          "description": "The absolute path to the source file"
        },
        {
          "name": "content",
          "type": "",
          "description": "The source file content to expand"
        },
        {
          "name": "version",
          "type": "",
          "description": "The file version (used for cache invalidation)"
        }
      ],
      "returns": {
        "type": "",
        "description": "An object containing:\n- `result`: The full ExpandResult from the native plugin (includes diagnostics, source mapping)\n- `code`: The expanded code (shorthand for result.code)"
      },
      "examples": [
        "```typescript\nconst { result, code } = processFile('/project/src/User.ts', sourceText, '1');\n```"
      ],
      "remarks": "The function handles several important concerns:\n1. **Empty file fast path**: Returns immediately for empty content\n2. **Virtual .d.ts management**: Creates/updates/removes companion type declaration files\n3. **Error recovery**: On expansion failure, returns original content and cleans up virtual files\nCaching is handled by the native Rust plugin based on the version parameter.\nIf the version hasn't changed since the last call, the cached result is returned.",
      "deprecated": null
    },
    {
      "name": "originalGetScriptVersion",
      "kind": "variable",
      "signature": "const originalGetScriptVersion",
      "description": "Hook: getScriptVersion\nProvides version strings for virtual `.macroforge.d.ts` files by deriving\nthem from the source file's version. This ensures TypeScript invalidates\nthe virtual file when its source changes.",
      "returns": null,
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "originalGetScriptFileNames",
      "kind": "variable",
      "signature": "const originalGetScriptFileNames",
      "description": "Hook: getScriptFileNames\nIncludes virtual `.macroforge.d.ts` files in the project's file list.\nThis allows TypeScript to \"see\" our generated type declaration files\nand include them in type checking and import resolution.",
      "returns": null,
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "originalFileExists",
      "kind": "variable",
      "signature": "const originalFileExists",
      "description": "Hook: fileExists\nMakes virtual `.macroforge.d.ts` files appear to exist on disk.\nThis allows TypeScript's module resolution to find our generated\ntype declaration files.",
      "returns": null,
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "originalGetScriptSnapshot",
      "kind": "variable",
      "signature": "const originalGetScriptSnapshot",
      "description": "Hook: getScriptSnapshot (CRITICAL)\nThis is the most important hook - it intercepts file content requests\nand returns macro-expanded code instead of the original source.\nThe hook handles several scenarios:\n1. Virtual .d.ts files - Returns the generated type declarations\n2. Reentrancy - Returns original content if file is already being processed\n3. Excluded files - Returns original content for node_modules, etc.\n4. Non-macro files - Returns original content if no @derive directives\n5. Macro files - Returns expanded content with generated methods",
      "returns": null,
      "remarks": "Caching strategy:\n- Uses `snapshotCache` for identity stability (TS incremental compiler needs this)\n- Uses `processingFiles` Set to prevent infinite loops during expansion\n- Version-based cache invalidation ensures fresh expansions on file changes",
      "deprecated": null
    },
    {
      "name": "toPlainDiagnostic",
      "kind": "function",
      "signature": "function toPlainDiagnostic(diag: ts.Diagnostic):",
      "description": "Converts a TypeScript diagnostic to a plain object for the native plugin.\nThe native Rust plugin expects a simplified diagnostic format. This function\nextracts the essential fields and normalizes the message text (which can be\neither a string or a DiagnosticMessageChain).",
      "params": [
        {
          "name": "diag",
          "type": "",
          "description": "The TypeScript diagnostic to convert"
        }
      ],
      "returns": {
        "type": "",
        "description": "A plain object with diagnostic information"
      },
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "applyMappedDiagnostics",
      "kind": "function",
      "signature": "function applyMappedDiagnostics(\n      original: readonly ts.Diagnostic[],\n      mapped: Array<",
      "description": "Applies mapped positions to diagnostics, updating their start/length.\nTakes the original diagnostics and a parallel array of mapped positions\n(from the native plugin) and creates new diagnostics with corrected positions\npointing to the original source instead of the expanded code.",
      "params": [
        {
          "name": "original",
          "type": "",
          "description": "The original diagnostics from TypeScript"
        },
        {
          "name": "mapped",
          "type": "",
          "description": "Array of mapped positions (parallel to original)"
        }
      ],
      "returns": {
        "type": "",
        "description": "New diagnostic array with corrected positions"
      },
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "originalGetSemanticDiagnostics",
      "kind": "variable",
      "signature": "const originalGetSemanticDiagnostics",
      "description": "Hook: getSemanticDiagnostics (COMPLEX)\nThis is one of the most complex hooks. It handles:\n1. Mapping TypeScript error positions from expanded code back to original\n2. Converting errors in generated code to point at the responsible @derive macro\n3. Injecting Macroforge-specific diagnostics (expansion errors, warnings)\nThe hook uses sophisticated position mapping to ensure errors appear at\nmeaningful locations in the user's source code, even when the actual error\noccurred in macro-generated code.",
      "returns": null,
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "originalGetSyntacticDiagnostics",
      "kind": "variable",
      "signature": "const originalGetSyntacticDiagnostics",
      "description": "Hook: getSyntacticDiagnostics\nMaps syntax error positions from expanded code back to original source.\nSimpler than semantic diagnostics as it doesn't need to handle generated\ncode errors (syntax errors are in user code, not generated code).",
      "returns": null,
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "originalGetQuickInfoAtPosition",
      "kind": "variable",
      "signature": "const originalGetQuickInfoAtPosition",
      "description": "Hook: getQuickInfoAtPosition\nProvides hover information for symbols. This hook has special handling\nfor Macroforge-specific syntax:\n1. First checks for macro hover info (@derive macros, field decorators)\n2. If not on a macro, maps position and delegates to TypeScript\n3. Maps result spans back to original positions",
      "returns": null,
      "remarks": "If the hover would be in generated code, returns undefined to hide it\n(prevents confusing users with hover info for code they can't see).",
      "deprecated": null
    },
    {
      "name": "originalGetCompletionsAtPosition",
      "kind": "variable",
      "signature": "const originalGetCompletionsAtPosition",
      "description": "Hook: getCompletionsAtPosition\nProvides IntelliSense completions. Maps the cursor position to expanded\ncoordinates to get accurate completions that include generated methods,\nthen maps any replacement spans back to original coordinates.",
      "returns": null,
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "originalGetDefinitionAtPosition",
      "kind": "variable",
      "signature": "const originalGetDefinitionAtPosition",
      "description": "Hook: getDefinitionAtPosition\nProvides \"Go to Definition\" functionality. Maps cursor position to\nexpanded code, gets definitions, then maps definition spans back\nto original positions.",
      "returns": null,
      "remarks": "For definitions in other files (not macro-expanded), positions are\npassed through unchanged. Only same-file definitions need mapping.\nDefinitions pointing to generated code are filtered out.",
      "deprecated": null
    },
    {
      "name": "originalGetDefinitionAndBoundSpan",
      "kind": "variable",
      "signature": "const originalGetDefinitionAndBoundSpan",
      "description": "Hook: getDefinitionAndBoundSpan\nEnhanced version of getDefinitionAtPosition that also returns the\ntext span that was used to find the definition (useful for highlighting).\nMaps both the bound span and definition spans.",
      "returns": null,
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "originalGetTypeDefinitionAtPosition",
      "kind": "variable",
      "signature": "const originalGetTypeDefinitionAtPosition",
      "description": "Hook: getTypeDefinitionAtPosition\nProvides \"Go to Type Definition\" functionality. Similar to\ngetDefinitionAtPosition but navigates to the type's definition\nrather than the symbol's definition.",
      "returns": null,
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "originalGetReferencesAtPosition",
      "kind": "variable",
      "signature": "const originalGetReferencesAtPosition",
      "description": "Hook: getReferencesAtPosition\nProvides \"Find All References\" functionality. Maps the cursor position,\nfinds all references in the expanded code, then maps each reference\nspan back to original positions. References in generated code are filtered.",
      "returns": null,
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "originalFindReferences",
      "kind": "variable",
      "signature": "const originalFindReferences",
      "description": "Hook: findReferences\nAlternative \"Find All References\" that returns grouped references by symbol.\nSimilar to getReferencesAtPosition but with richer structure.",
      "returns": null,
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "originalGetSignatureHelpItems",
      "kind": "variable",
      "signature": "const originalGetSignatureHelpItems",
      "description": "Hook: getSignatureHelpItems\nProvides function signature help (parameter hints shown while typing\nfunction arguments). Maps cursor position and the applicable span.",
      "returns": null,
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "originalGetRenameInfo",
      "kind": "variable",
      "signature": "const originalGetRenameInfo",
      "description": "Hook: getRenameInfo\nProvides information about whether a symbol can be renamed and what\ntext span should be highlighted. Returns an error message if the\ncursor is in generated code (can't rename generated symbols).",
      "returns": null,
      "remarks": "Uses a compatibility wrapper (callGetRenameInfo) to handle different\nTypeScript version signatures for this method.",
      "deprecated": null
    },
    {
      "name": "RenameInfoOptions",
      "kind": "type",
      "signature": "type RenameInfoOptions",
      "description": "",
      "returns": null,
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "callGetRenameInfo",
      "kind": "variable",
      "signature": "const callGetRenameInfo",
      "description": "Compatibility wrapper for getRenameInfo that handles both old and new\nTypeScript API signatures.",
      "returns": null,
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "originalFindRenameLocations",
      "kind": "variable",
      "signature": "const originalFindRenameLocations",
      "description": "Hook: findRenameLocations\nFinds all locations that would be affected by a rename operation.\nMaps each location's span back to original positions. Locations in\ngenerated code are filtered out.",
      "returns": null,
      "remarks": "Uses a compatibility wrapper (callFindRenameLocations) to handle\ndifferent TypeScript version signatures.",
      "deprecated": null
    },
    {
      "name": "RenameLocationOptions",
      "kind": "type",
      "signature": "type RenameLocationOptions",
      "description": "",
      "returns": null,
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "callFindRenameLocations",
      "kind": "variable",
      "signature": "const callFindRenameLocations",
      "description": "Compatibility wrapper for findRenameLocations that handles both old\nand new TypeScript API signatures.",
      "returns": null,
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "originalGetDocumentHighlights",
      "kind": "variable",
      "signature": "const originalGetDocumentHighlights",
      "description": "Hook: getDocumentHighlights\nHighlights all occurrences of a symbol in the document (used when you\nclick on a variable and see all usages highlighted). Maps highlight\nspans back to original positions.",
      "returns": null,
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "originalGetImplementationAtPosition",
      "kind": "variable",
      "signature": "const originalGetImplementationAtPosition",
      "description": "Hook: getImplementationAtPosition\nProvides \"Go to Implementation\" functionality. Similar to definition\nbut finds concrete implementations of abstract methods/interfaces.",
      "returns": null,
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "originalGetCodeFixesAtPosition",
      "kind": "variable",
      "signature": "const originalGetCodeFixesAtPosition",
      "description": "Hook: getCodeFixesAtPosition\nProvides quick fix suggestions for errors at a position. Maps the\ninput span to expanded coordinates to get fixes that work with\ngenerated code context.",
      "returns": null,
      "remarks": "Note: The returned fixes may include edits to expanded code, which\ncould be problematic. Consider filtering or mapping fix edits in\nfuture versions.",
      "deprecated": null
    },
    {
      "name": "originalGetNavigationTree",
      "kind": "variable",
      "signature": "const originalGetNavigationTree",
      "description": "Hook: getNavigationTree\nProvides the document outline/structure tree (shown in the Outline\npanel). Recursively maps all spans in the tree back to original positions.",
      "returns": null,
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "originalGetOutliningSpans",
      "kind": "variable",
      "signature": "const originalGetOutliningSpans",
      "description": "Hook: getOutliningSpans\nProvides code folding regions. Maps both the text span (what gets\nfolded) and hint span (what's shown when collapsed) back to original.",
      "returns": null,
      "remarks": null,
      "deprecated": null
    },
    {
      "name": "originalProvideInlayHints",
      "kind": "variable",
      "signature": "const originalProvideInlayHints",
      "description": "Hook: provideInlayHints\nProvides inlay hints (inline type annotations shown in the editor).\nMaps the requested span to expanded coordinates, then maps each hint's\nposition back to original. Hints in generated code are filtered out.",
      "returns": null,
      "remarks": "This hook is conditional - provideInlayHints may not exist in older\nTypeScript versions.",
      "deprecated": null
    }
  ]
}