{
  "name": "macroforge_ts",
  "kind": "rust_crate",
  "version": "0.1.54",
  "description": "TypeScript macro expansion engine - write compile-time macros in Rust",
  "overview": "# Macroforge TypeScript Macro Engine\n\nThis crate provides a TypeScript macro expansion engine that brings Rust-like derive macros\nto TypeScript. It is designed to be used via NAPI bindings from Node.js, enabling compile-time\ncode generation for TypeScript projects.\n\n## Overview\n\nMacroforge processes TypeScript source files containing `@derive` decorators and expands them\ninto concrete implementations. For example, a class decorated with `@derive(Debug, Clone)`\nwill have `toString()` and `clone()` methods automatically generated.\n\n## Architecture\n\nThe crate is organized into several key components:\n\n- **NAPI Bindings** (`NativePlugin`, `expand_sync`, `transform_sync`): Entry points for Node.js\n- **Position Mapping** (`NativePositionMapper`, `NativeMapper`): Bidirectional source mapping\n  for IDE integration\n- **Macro Host** (`host` module): Core expansion engine with registry and dispatcher\n- **Built-in Macros** (`builtin` module): Standard derive macros (Debug, Clone, Serialize, etc.)\n\n## Performance Considerations\n\n- Uses a 32MB thread stack to prevent stack overflow during deep SWC AST recursion\n- Implements early bailout for files without `@derive` decorators\n- Caches expansion results keyed by filepath and version\n- Uses binary search for O(log n) position mapping lookups\n\n## Usage from Node.js\n\n```javascript\nconst { NativePlugin, expand_sync } = require('macroforge-ts');\n\n// Create a plugin instance with caching\nconst plugin = new NativePlugin();\n\n// Process a file (uses cache if version matches)\nconst result = plugin.process_file(filepath, code, { version: '1.0' });\n\n// Or use the sync function directly\nconst result = expand_sync(code, filepath, { keep_decorators: false });\n```\n\n## Re-exports for Macro Authors\n\nThis crate re-exports several dependencies for convenience when writing custom macros:\n- `ts_syn`: TypeScript syntax types for AST manipulation\n- `macros`: Macro attributes and quote templates\n- `swc_core`, `swc_common`, `swc_ecma_ast`: SWC compiler infrastructure",
  "items": [
    {
      "name": "macros",
      "kind": "module",
      "signature": "pub mod macros",
      "description": "Macro attributes and quote templates\nUse: `use macroforge_ts::macros::*;`"
    },
    {
      "name": "TransformResult",
      "kind": "struct",
      "signature": "pub struct TransformResult",
      "description": "Result of transforming TypeScript code through the macro system.\n\nThis struct is returned by [`transform_sync`] and contains the transformed code\nalong with optional source maps, type declarations, and metadata about processed classes."
    },
    {
      "name": "MacroDiagnostic",
      "kind": "struct",
      "signature": "pub struct MacroDiagnostic",
      "description": "A diagnostic message produced during macro expansion.\n\nDiagnostics can represent errors, warnings, or informational messages\nthat occurred during the macro expansion process.",
      "examples": [
        "use macroforge_ts::MacroDiagnostic;\n\nlet _diag = MacroDiagnostic {\n    level: \"error\".to_string(),\n    message: \"Unknown macro 'Foo'\".to_string(),\n    start: Some(42),\n    end: Some(45),\n};"
      ]
    },
    {
      "name": "MappingSegmentResult",
      "kind": "struct",
      "signature": "pub struct MappingSegmentResult",
      "description": "A segment mapping a range in the original source to a range in the expanded source.\n\nThese segments form the core of the bidirectional source mapping system,\nenabling IDE features like \"go to definition\" and error reporting to work\ncorrectly with macro-expanded code."
    },
    {
      "name": "GeneratedRegionResult",
      "kind": "struct",
      "signature": "pub struct GeneratedRegionResult",
      "description": "A region in the expanded source that was generated by a macro.\n\nThese regions identify code that has no corresponding location in the\noriginal source because it was synthesized by a macro."
    },
    {
      "name": "SourceMappingResult",
      "kind": "struct",
      "signature": "pub struct SourceMappingResult",
      "description": "Complete source mapping information for a macro expansion.\n\nContains both preserved segments (original code that wasn't modified)\nand generated regions (new code synthesized by macros)."
    },
    {
      "name": "ExpandResult",
      "kind": "struct",
      "signature": "pub struct ExpandResult",
      "description": "Result of expanding macros in TypeScript source code.\n\nThis is the primary return type for macro expansion operations,\ncontaining the expanded code, diagnostics, and source mapping.",
      "examples": [
        "use macroforge_ts::{ExpandResult, MacroDiagnostic};\n\n// Create an ExpandResult programmatically\nlet result = ExpandResult {\n    code: \"class User {}\".to_string(),\n    types: None,\n    metadata: None,\n    diagnostics: vec![],\n    source_mapping: None,\n};\n\n// Check for errors\nif result.diagnostics.iter().any(|d| d.level == \"error\") {\n    // Handle errors\n}"
      ]
    },
    {
      "name": "ImportSourceResult",
      "kind": "struct",
      "signature": "pub struct ImportSourceResult",
      "description": "Information about an imported identifier from a TypeScript module.\n\nUsed to track where decorators and macro-related imports come from."
    },
    {
      "name": "SyntaxCheckResult",
      "kind": "struct",
      "signature": "pub struct SyntaxCheckResult",
      "description": "Result of checking TypeScript syntax validity.\n\nReturned by [`check_syntax`] to indicate whether code parses successfully."
    },
    {
      "name": "SpanResult",
      "kind": "struct",
      "signature": "pub struct SpanResult",
      "description": "A span (range) in source code, represented as start position and length.\n\nUsed for mapping diagnostics and other positional information."
    },
    {
      "name": "JsDiagnostic",
      "kind": "struct",
      "signature": "pub struct JsDiagnostic",
      "description": "A diagnostic from the TypeScript/JavaScript compiler or IDE.\n\nThis structure mirrors TypeScript's diagnostic format for interoperability\nwith language servers and IDEs."
    },
    {
      "name": "NativePositionMapper",
      "kind": "struct",
      "signature": "pub struct NativePositionMapper",
      "description": "Bidirectional position mapper for translating between original and expanded source positions.\n\nThis mapper enables IDE features like error reporting, go-to-definition, and hover\nto work correctly with macro-expanded code by translating positions between the\noriginal source (what the user wrote) and the expanded source (what the compiler sees).",
      "examples": [
        "const mapper = new PositionMapper(sourceMapping);\n\n// Convert original position to expanded\nconst expandedPos = mapper.original_to_expanded(42);\n\n// Convert expanded position back to original (if not in generated code)\nconst originalPos = mapper.expanded_to_original(100);\n\n// Check if a position is in macro-generated code\nif (mapper.is_in_generated(pos)) {\n    const macro = mapper.generated_by(pos); // e.g., \"Debug\"\n}"
      ]
    },
    {
      "name": "NativeMapper",
      "kind": "struct",
      "signature": "pub struct NativeMapper",
      "description": "Wrapper around `NativePositionMapper` for NAPI compatibility.\n\nThis provides the same functionality as `NativePositionMapper` but with a\ndifferent JavaScript class name. Used internally by [`NativePlugin::get_mapper`]."
    },
    {
      "name": "check_syntax",
      "kind": "function",
      "signature": "pub fn check_syntax(code : String, filepath : String) -> SyntaxCheckResult",
      "description": "Checks if the given TypeScript code has valid syntax.\n\nThis function attempts to parse the code using SWC's TypeScript parser\nwithout performing any macro expansion.",
      "params": [
        {
          "name": "code",
          "type": "",
          "description": "The TypeScript source code to check"
        },
        {
          "name": "filepath",
          "type": "",
          "description": "The file path (used to determine if it's TSX based on extension)"
        }
      ],
      "returns": {
        "type": "",
        "description": "A [`SyntaxCheckResult`] indicating success or containing the parse error."
      },
      "examples": [
        "const result = check_syntax(\"const x: number = 42;\", \"test.ts\");\nif (!result.ok) {\n    console.error(\"Syntax error:\", result.error);\n}"
      ]
    },
    {
      "name": "ProcessFileOptions",
      "kind": "struct",
      "signature": "pub struct ProcessFileOptions",
      "description": "Options for processing a file through the macro system.\n\nUsed by [`NativePlugin::process_file`] to configure expansion behavior\nand caching."
    },
    {
      "name": "ExpandOptions",
      "kind": "struct",
      "signature": "pub struct ExpandOptions",
      "description": "Options for macro expansion.\n\nUsed by [`expand_sync`] to configure expansion behavior."
    },
    {
      "name": "NativePlugin",
      "kind": "struct",
      "signature": "pub struct NativePlugin",
      "description": "The main plugin class for macro expansion with caching support.\n\n`NativePlugin` is designed to be instantiated once and reused across multiple\nfile processing operations. It maintains a cache of expansion results keyed\nby filepath and version, enabling efficient incremental processing.",
      "examples": [
        "// Create a single plugin instance (typically at startup)\nconst plugin = new NativePlugin();\n\n// Process files with caching\nconst result1 = plugin.process_file(\"src/foo.ts\", code1, { version: \"1\" });\nconst result2 = plugin.process_file(\"src/foo.ts\", code2, { version: \"1\" }); // Cache hit!\nconst result3 = plugin.process_file(\"src/foo.ts\", code3, { version: \"2\" }); // Cache miss\n\n// Get a mapper for position translation\nconst mapper = plugin.get_mapper(\"src/foo.ts\");"
      ]
    },
    {
      "name": "parse_import_sources",
      "kind": "function",
      "signature": "pub fn parse_import_sources(code : String, filepath : String) -> Result < Vec < ImportSourceResult > >",
      "description": "Parses import statements from TypeScript code and returns their sources.\n\nThis function extracts information about all import statements in the code,\nmapping each imported identifier to its source module. Useful for analyzing\ndependencies and understanding where decorators come from.",
      "params": [
        {
          "name": "code",
          "type": "",
          "description": "The TypeScript source code to parse"
        },
        {
          "name": "filepath",
          "type": "",
          "description": "The file path (used for TSX detection)"
        }
      ],
      "returns": {
        "type": "",
        "description": "A vector of [`ImportSourceResult`] entries, one for each imported identifier."
      },
      "examples": [
        "// For code: import { Derive, Clone } from \"macroforge-ts\";\nconst imports = parse_import_sources(code, \"test.ts\");\n// Returns: [\n//   { local: \"Derive\", module: \"macroforge-ts\" },\n//   { local: \"Clone\", module: \"macroforge-ts\" }\n// ]"
      ],
      "errors": "Returns an error if the code cannot be parsed."
    },
    {
      "name": "derive_decorator",
      "kind": "function",
      "signature": "pub fn derive_decorator()",
      "description": "The `@Derive` decorator function exported to JavaScript/TypeScript.\n\nThis is a no-op function that exists purely for TypeScript type checking.\nThe actual decorator processing happens during macro expansion, where\n`@derive(...)` decorators are recognized and transformed."
    },
    {
      "name": "LoadConfigResult",
      "kind": "struct",
      "signature": "pub struct LoadConfigResult",
      "description": "Result of loading a macroforge configuration file.\n\nReturned by [`load_config`] after parsing a `macroforge.config.js/ts` file."
    },
    {
      "name": "load_config",
      "kind": "function",
      "signature": "pub fn load_config(content : String, filepath : String) -> Result < LoadConfigResult >",
      "description": "Load and parse a macroforge configuration file.\n\nParses a `macroforge.config.js/ts` file and caches the result for use\nduring macro expansion. The configuration includes both simple settings\n(like `keepDecorators`) and foreign type handlers.",
      "params": [
        {
          "name": "content",
          "type": "",
          "description": "The raw content of the configuration file"
        },
        {
          "name": "filepath",
          "type": "",
          "description": "Path to the configuration file (used to determine syntax and as cache key)"
        }
      ],
      "returns": {
        "type": "",
        "description": "A [`LoadConfigResult`] containing the parsed configuration summary."
      },
      "examples": [
        "import { loadConfig, expandSync } from 'macroforge';\nimport fs from 'fs';\n\nconst configPath = 'macroforge.config.js';\nconst configContent = fs.readFileSync(configPath, 'utf-8');\n\n// Load and cache the configuration\nconst result = loadConfig(configContent, configPath);\nconsole.log(`Loaded config with ${result.foreignTypeCount} foreign types`);\n\n// The config is now cached and will be used by expandSync\nconst expanded = expandSync(code, filepath, { configPath });"
      ]
    },
    {
      "name": "clear_config_cache",
      "kind": "function",
      "signature": "pub fn clear_config_cache()",
      "description": "Clears the configuration cache.\n\nThis is useful for testing to ensure each test starts with a clean state.\nIn production, clearing the cache will force configs to be re-parsed on next access.",
      "examples": [
        "const { clearConfigCache, loadConfig } = require('macroforge-ts');\n\n// Clear cache before each test\nclearConfigCache();\n\n// Now load a fresh config\nconst result = loadConfig(configContent, configPath);"
      ]
    },
    {
      "name": "transform_sync",
      "kind": "function",
      "signature": "pub fn transform_sync(_env : Env, code : String, filepath : String) -> Result < TransformResult >",
      "description": "Synchronously transforms TypeScript code through the macro expansion system.\n\nThis is similar to [`expand_sync`] but returns a [`TransformResult`] which\nincludes source map information (when available).",
      "params": [
        {
          "name": "_env",
          "type": "",
          "description": "NAPI environment (unused but required by NAPI)"
        },
        {
          "name": "code",
          "type": "",
          "description": "The TypeScript source code to transform"
        },
        {
          "name": "filepath",
          "type": "",
          "description": "The file path (used for TSX detection)"
        }
      ],
      "returns": {
        "type": "",
        "description": "A [`TransformResult`] containing the transformed code and metadata."
      },
      "errors": "Returns an error if:\n- Thread spawning fails\n- The worker thread panics\n- Macro expansion fails"
    },
    {
      "name": "expand_sync",
      "kind": "function",
      "signature": "pub fn expand_sync(_env : Env, code : String, filepath : String, options : Option < ExpandOptions >) -> Result < ExpandResult >",
      "description": "Synchronously expands macros in TypeScript code.\n\nThis is the standalone macro expansion function that doesn't use caching.\nFor cached expansion, use [`NativePlugin::process_file`] instead.",
      "params": [
        {
          "name": "_env",
          "type": "",
          "description": "NAPI environment (unused but required by NAPI)"
        },
        {
          "name": "code",
          "type": "",
          "description": "The TypeScript source code to expand"
        },
        {
          "name": "filepath",
          "type": "",
          "description": "The file path (used for TSX detection)"
        },
        {
          "name": "options",
          "type": "",
          "description": "Optional configuration (e.g., `keep_decorators`)"
        }
      ],
      "returns": {
        "type": "",
        "description": "An [`ExpandResult`] containing the expanded code, diagnostics, and source mapping."
      },
      "examples": [
        "const result = expand_sync(env, code, \"user.ts\", { keep_decorators: false });\nconsole.log(result.code); // Expanded TypeScript code\nconsole.log(result.diagnostics); // Any warnings or errors"
      ],
      "errors": "Returns an error if:\n- Thread spawning fails\n- The worker thread panics\n- Macro host initialization fails"
    },
    {
      "name": "MacroManifestEntry",
      "kind": "struct",
      "signature": "pub struct MacroManifestEntry",
      "description": "Entry for a registered macro in the manifest.\n\nUsed by [`MacroManifest`] to describe available macros to tooling\nsuch as IDE extensions and documentation generators."
    },
    {
      "name": "DecoratorManifestEntry",
      "kind": "struct",
      "signature": "pub struct DecoratorManifestEntry",
      "description": "Entry for a registered decorator in the manifest.\n\nUsed by [`MacroManifest`] to describe field-level decorators\nthat can be used with macros."
    },
    {
      "name": "MacroManifest",
      "kind": "struct",
      "signature": "pub struct MacroManifest",
      "description": "Complete manifest of all available macros and decorators.\n\nThis is returned by [`get_macro_manifest`] and is useful for:\n- IDE autocompletion\n- Documentation generation\n- Tooling integration"
    },
    {
      "name": "get_macro_manifest",
      "kind": "function",
      "signature": "pub fn get_macro_manifest() -> MacroManifest",
      "description": "Returns the complete manifest of all registered macros and decorators.\n\nThis is a debug/introspection API that allows tooling to discover\nwhat macros are available at runtime.",
      "returns": {
        "type": "",
        "description": "A [`MacroManifest`] containing all registered macros and decorators."
      }
    },
    {
      "name": "is_macro_package",
      "kind": "function",
      "signature": "pub fn is_macro_package() -> bool",
      "description": "Checks if any macros are registered in this package.\n\nUseful for build tools to determine if macro expansion is needed.",
      "returns": {
        "type": "",
        "description": "`true` if at least one macro is registered, `false` otherwise."
      }
    },
    {
      "name": "get_macro_names",
      "kind": "function",
      "signature": "pub fn get_macro_names() -> Vec < String >",
      "description": "Returns the names of all registered macros.",
      "returns": {
        "type": "",
        "description": "A vector of macro names (e.g., `[\"Debug\", \"Clone\", \"Serialize\"]`)."
      }
    },
    {
      "name": "debug_get_modules",
      "kind": "function",
      "signature": "pub fn debug_get_modules() -> Vec < String >",
      "description": "Returns all registered macro module names (debug API).\n\nModules group related macros together (e.g., \"builtin\", \"serde\").",
      "returns": {
        "type": "",
        "description": "A vector of module names."
      }
    },
    {
      "name": "debug_lookup",
      "kind": "function",
      "signature": "pub fn debug_lookup(module : String, name : String) -> String",
      "description": "Looks up a macro by module and name (debug API).\n\nUseful for testing macro registration and debugging lookup issues.",
      "params": [
        {
          "name": "module",
          "type": "",
          "description": "The module name (e.g., \"builtin\")"
        },
        {
          "name": "name",
          "type": "",
          "description": "The macro name (e.g., \"Debug\")"
        }
      ],
      "returns": {
        "type": "",
        "description": "A string describing whether the macro was found or not."
      }
    },
    {
      "name": "debug_descriptors",
      "kind": "function",
      "signature": "pub fn debug_descriptors() -> Vec < String >",
      "description": "Returns debug information about all registered macro descriptors (debug API).\n\nThis provides low-level access to the inventory-based macro registration\nsystem for debugging purposes.",
      "returns": {
        "type": "",
        "description": "A vector of strings describing each registered macro descriptor."
      }
    }
  ]
}