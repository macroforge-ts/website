{
  "deserialize": {
    "name": "Deserialize",
    "slug": "deserialize",
    "description": "The `Deserialize` macro generates JSON deserialization methods with **cycle and\nforward-reference support**, plus comprehensive runtime validation. This enables\nsafe parsing of complex JSON structures including circular references.",
    "generatedOutput": "| Type | Generated Code | Description |\n|------|----------------|-------------|\n| Class | `classNameDeserialize(input)` + `static deserialize(input)` | Standalone function + static factory method |\n| Enum | `enumNameDeserialize(input)`, `enumNameDeserializeWithContext(data)`, `enumNameIs(value)` | Standalone functions |\n| Interface | `interfaceNameDeserialize(input)`, etc. | Standalone functions |\n| Type Alias | `typeNameDeserialize(input)`, etc. | Standalone functions |",
    "fieldOptions": "- `denyUnknownFields` - Error on unrecognized JSON properties\n- `renameAll = \"camelCase\"` - Apply naming convention to all fields",
    "example": "```typescript\n/** @derive(Deserialize) @serde({ denyUnknownFields: true }) */\nclass User {\n    id: number;\n\n    /** @serde({ validate: { email: true, maxLength: 255 } }) */\n    email: string;\n\n    /** @serde({ default: \"guest\" }) */\n    name: string;\n\n    /** @serde({ validate: { positive: true } }) */\n    age?: number;\n}\n```\n\nGenerated output:\n\n```typescript\nimport { DeserializeContext } from 'macroforge/serde';\nimport { DeserializeError } from 'macroforge/serde';\nimport type { DeserializeOptions } from 'macroforge/serde';\nimport { PendingRef } from 'macroforge/serde';\n\n/** @serde({ denyUnknownFields: true }) */\nclass User {\n    id: number;\n\n    email: string;\n\n    name: string;\n\n    age?: number;\n\n    constructor(props: {\n        id: number;\n        email: string;\n        name?: string;\n        age?: number;\n    }) {\n        this.id = props.id;\n        this.email = props.email;\n        this.name = props.name as string;\n        this.age = props.age as number;\n    }\n\n    /**\n     * Deserializes input to an instance of this class.\n     * Automatically detects whether input is a JSON string or object.\n     * @param input - JSON string or object to deserialize\n     * @param opts - Optional deserialization options\n     * @returns Result containing the deserialized instance or validation errors\n     */\n    static deserialize(\n        input: unknown,\n        opts?: @{DESERIALIZE_OPTIONS}\n    ): Result<\n        User,\n        Array<{\n            field: string;\n            message: string;\n        }>\n    > {\n        try {\n            // Auto-detect: if string, parse as JSON first\n            const data = typeof input === 'string' ? JSON.parse(input) : input;\n\n            const ctx = @{DESERIALIZE_CONTEXT}.create();\n            const resultOrRef = User.deserializeWithContext(data, ctx);\n            if (@{PENDING_REF}.is(resultOrRef)) {\n                return Result.err([\n                    {\n                        field: '_root',\n                        message: 'User.deserialize: root cannot be a forward reference'\n                    }\n                ]);\n            }\n            ctx.applyPatches();\n            if (opts?.freeze) {\n                ctx.freezeAll();\n            }\n            return Result.ok(resultOrRef);\n        } catch (e) {\n            if (e instanceof @{DESERIALIZE_ERROR}) {\n                return Result.err(e.errors);\n            }\n            const message = e instanceof Error ? e.message : String(e);\n            return Result.err([\n                {\n                    field: '_root',\n                    message\n                }\n            ]);\n        }\n    }\n\n    /** @internal */\n    static deserializeWithContext(value: any, ctx: @{DESERIALIZE_CONTEXT}): User | @{PENDING_REF} {\n        if (value?.__ref !== undefined) {\n            return ctx.getOrDefer(value.__ref);\n        }\n        if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n            throw new @{DESERIALIZE_ERROR}([\n                {\n                    field: '_root',\n                    message: 'User.deserializeWithContext: expected an object'\n                }\n            ]);\n        }\n        const obj = value as Record<string, unknown>;\n        const errors: Array<{\n            field: string;\n            message: string;\n        }> = [];\n        const knownKeys = new Set(['__type', '__id', '__ref', 'id', 'email', 'name', 'age']);\n        for (const key of Object.keys(obj)) {\n            if (!knownKeys.has(key)) {\n                errors.push({\n                    field: key,\n                    message: 'unknown field'\n                });\n            }\n        }\n        if (!('id' in obj)) {\n            errors.push({\n                field: 'id',\n                message: 'missing required field'\n            });\n        }\n        if (!('email' in obj)) {\n            errors.push({\n                field: 'email',\n                message: 'missing required field'\n            });\n        }\n        if (errors.length > 0) {\n            throw new @{DESERIALIZE_ERROR}(errors);\n        }\n        const instance = Object.create(User.prototype) as User;\n        if (obj.__id !== undefined) {\n            ctx.register(obj.__id as number, instance);\n        }\n        ctx.trackForFreeze(instance);\n        {\n            const __raw_id = obj['id'] as number;\n            instance.id = __raw_id;\n        }\n        {\n            const __raw_email = obj['email'] as string;\n            instance.email = __raw_email;\n        }\n        if ('name' in obj && obj['name'] !== undefined) {\n            const __raw_name = obj['name'] as string;\n            instance.name = __raw_name;\n        } else {\n            instance.name = \"guest\";\n        }\n        if ('age' in obj && obj['age'] !== undefined) {\n            const __raw_age = obj['age'] as number;\n            instance.age = __raw_age;\n        }\n        if (errors.length > 0) {\n            throw new @{DESERIALIZE_ERROR}(errors);\n        }\n        return instance;\n    }\n\n    static validateField<K extends keyof User>(\n        field: K,\n        value: User[K]\n    ): Array<{\n        field: string;\n        message: string;\n    }> {\n        return [];\n    }\n\n    static validateFields(partial: Partial<User>): Array<{\n        field: string;\n        message: string;\n    }> {\n        return [];\n    }\n\n    static hasShape(obj: unknown): boolean {\n        if (typeof obj !== 'object' || obj === null || Array.isArray(obj)) {\n            return false;\n        }\n        const o = obj as Record<string, unknown>;\n        return 'id' in o && 'email' in o;\n    }\n\n    static is(obj: unknown): obj is User {\n        if (obj instanceof User) {\n            return true;\n        }\n        if (!User.hasShape(obj)) {\n            return false;\n        }\n        const result = User.deserialize(obj);\n        return Result.isOk(result);\n    }\n}\n\n// Usage:\nconst result = User.deserialize('{\"id\":1,\"email\":\"test@example.com\"}');\nif (Result.isOk(result)) {\n    const user = result.value;\n} else {\n    console.error(result.error); // [{ field: \"email\", message: \"must be a valid email\" }]\n}\n```",
    "exampleCode": [
      {
        "lang": "typescript",
        "code": "/** @derive(Deserialize) @serde({ denyUnknownFields: true }) */\nclass User {\n    id: number;\n\n    /** @serde({ validate: { email: true, maxLength: 255 } }) */\n    email: string;\n\n    /** @serde({ default: \"guest\" }) */\n    name: string;\n\n    /** @serde({ validate: { positive: true } }) */\n    age?: number;\n}",
        "rawCode": "/** @derive(Deserialize) @serde({ denyUnknownFields: true }) */\nclass User {\n    id: number;\n\n    /** @serde({ validate: { email: true, maxLength: 255 } }) */\n    email: string;\n\n    /** @serde({ default: \"guest\" }) */\n    name: string;\n\n    /** @serde({ validate: { positive: true } }) */\n    age?: number;\n}"
      },
      {
        "lang": "typescript",
        "code": "import { DeserializeContext } from 'macroforge/serde';\nimport { DeserializeError } from 'macroforge/serde';\nimport type { DeserializeOptions } from 'macroforge/serde';\nimport { PendingRef } from 'macroforge/serde';\n\n/** @serde({ denyUnknownFields: true }) */\nclass User {\n    id: number;\n\n    email: string;\n\n    name: string;\n\n    age?: number;\n\n    constructor(props: {\n        id: number;\n        email: string;\n        name?: string;\n        age?: number;\n    }) {\n        this.id = props.id;\n        this.email = props.email;\n        this.name = props.name as string;\n        this.age = props.age as number;\n    }\n\n    /**\n     * Deserializes input to an instance of this class.\n     * Automatically detects whether input is a JSON string or object.\n     * @param input - JSON string or object to deserialize\n     * @param opts - Optional deserialization options\n     * @returns Result containing the deserialized instance or validation errors\n     */\n    static deserialize(\n        input: unknown,\n        opts?: @{DESERIALIZE_OPTIONS}\n    ): Result<\n        User,\n        Array<{\n            field: string;\n            message: string;\n        }>\n    > {\n        try {\n            // Auto-detect: if string, parse as JSON first\n            const data = typeof input === 'string' ? JSON.parse(input) : input;\n\n            const ctx = @{DESERIALIZE_CONTEXT}.create();\n            const resultOrRef = User.deserializeWithContext(data, ctx);\n            if (@{PENDING_REF}.is(resultOrRef)) {\n                return Result.err([\n                    {\n                        field: '_root',\n                        message: 'User.deserialize: root cannot be a forward reference'\n                    }\n                ]);\n            }\n            ctx.applyPatches();\n            if (opts?.freeze) {\n                ctx.freezeAll();\n            }\n            return Result.ok(resultOrRef);\n        } catch (e) {\n            if (e instanceof @{DESERIALIZE_ERROR}) {\n                return Result.err(e.errors);\n            }\n            const message = e instanceof Error ? e.message : String(e);\n            return Result.err([\n                {\n                    field: '_root',\n                    message\n                }\n            ]);\n        }\n    }\n\n    /** @internal */\n    static deserializeWithContext(value: any, ctx: @{DESERIALIZE_CONTEXT}): User | @{PENDING_REF} {\n        if (value?.__ref !== undefined) {\n            return ctx.getOrDefer(value.__ref);\n        }\n        if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n            throw new @{DESERIALIZE_ERROR}([\n                {\n                    field: '_root',\n                    message: 'User.deserializeWithContext: expected an object'\n                }\n            ]);\n        }\n        const obj = value as Record<string, unknown>;\n        const errors: Array<{\n            field: string;\n            message: string;\n        }> = [];\n        const knownKeys = new Set(['__type', '__id', '__ref', 'id', 'email', 'name', 'age']);\n        for (const key of Object.keys(obj)) {\n            if (!knownKeys.has(key)) {\n                errors.push({\n                    field: key,\n                    message: 'unknown field'\n                });\n            }\n        }\n        if (!('id' in obj)) {\n            errors.push({\n                field: 'id',\n                message: 'missing required field'\n            });\n        }\n        if (!('email' in obj)) {\n            errors.push({\n                field: 'email',\n                message: 'missing required field'\n            });\n        }\n        if (errors.length > 0) {\n            throw new @{DESERIALIZE_ERROR}(errors);\n        }\n        const instance = Object.create(User.prototype) as User;\n        if (obj.__id !== undefined) {\n            ctx.register(obj.__id as number, instance);\n        }\n        ctx.trackForFreeze(instance);\n        {\n            const __raw_id = obj['id'] as number;\n            instance.id = __raw_id;\n        }\n        {\n            const __raw_email = obj['email'] as string;\n            instance.email = __raw_email;\n        }\n        if ('name' in obj && obj['name'] !== undefined) {\n            const __raw_name = obj['name'] as string;\n            instance.name = __raw_name;\n        } else {\n            instance.name = \"guest\";\n        }\n        if ('age' in obj && obj['age'] !== undefined) {\n            const __raw_age = obj['age'] as number;\n            instance.age = __raw_age;\n        }\n        if (errors.length > 0) {\n            throw new @{DESERIALIZE_ERROR}(errors);\n        }\n        return instance;\n    }\n\n    static validateField<K extends keyof User>(\n        field: K,\n        value: User[K]\n    ): Array<{\n        field: string;\n        message: string;\n    }> {\n        return [];\n    }\n\n    static validateFields(partial: Partial<User>): Array<{\n        field: string;\n        message: string;\n    }> {\n        return [];\n    }\n\n    static hasShape(obj: unknown): boolean {\n        if (typeof obj !== 'object' || obj === null || Array.isArray(obj)) {\n            return false;\n        }\n        const o = obj as Record<string, unknown>;\n        return 'id' in o && 'email' in o;\n    }\n\n    static is(obj: unknown): obj is User {\n        if (obj instanceof User) {\n            return true;\n        }\n        if (!User.hasShape(obj)) {\n            return false;\n        }\n        const result = User.deserialize(obj);\n        return Result.isOk(result);\n    }\n}\n\n// Usage:\nconst result = User.deserialize('{\"id\":1,\"email\":\"test@example.com\"}');\nif (Result.isOk(result)) {\n    const user = result.value;\n} else {\n    console.error(result.error); // [{ field: \"email\", message: \"must be a valid email\" }]\n}",
        "rawCode": "import { DeserializeContext } from 'macroforge/serde';\nimport { DeserializeError } from 'macroforge/serde';\nimport type { DeserializeOptions } from 'macroforge/serde';\nimport { PendingRef } from 'macroforge/serde';\n\n/** @serde({ denyUnknownFields: true }) */\nclass User {\n    id: number;\n\n    email: string;\n\n    name: string;\n\n    age?: number;\n\n    constructor(props: {\n        id: number;\n        email: string;\n        name?: string;\n        age?: number;\n    }) {\n        this.id = props.id;\n        this.email = props.email;\n        this.name = props.name as string;\n        this.age = props.age as number;\n    }\n\n    /**\n     * Deserializes input to an instance of this class.\n     * Automatically detects whether input is a JSON string or object.\n     * @param input - JSON string or object to deserialize\n     * @param opts - Optional deserialization options\n     * @returns Result containing the deserialized instance or validation errors\n     */\n    static deserialize(\n        input: unknown,\n        opts?: @{DESERIALIZE_OPTIONS}\n    ): Result<\n        User,\n        Array<{\n            field: string;\n            message: string;\n        }>\n    > {\n        try {\n            // Auto-detect: if string, parse as JSON first\n            const data = typeof input === 'string' ? JSON.parse(input) : input;\n\n            const ctx = @{DESERIALIZE_CONTEXT}.create();\n            const resultOrRef = User.deserializeWithContext(data, ctx);\n            if (@{PENDING_REF}.is(resultOrRef)) {\n                return Result.err([\n                    {\n                        field: '_root',\n                        message: 'User.deserialize: root cannot be a forward reference'\n                    }\n                ]);\n            }\n            ctx.applyPatches();\n            if (opts?.freeze) {\n                ctx.freezeAll();\n            }\n            return Result.ok(resultOrRef);\n        } catch (e) {\n            if (e instanceof @{DESERIALIZE_ERROR}) {\n                return Result.err(e.errors);\n            }\n            const message = e instanceof Error ? e.message : String(e);\n            return Result.err([\n                {\n                    field: '_root',\n                    message\n                }\n            ]);\n        }\n    }\n\n    /** @internal */\n    static deserializeWithContext(value: any, ctx: @{DESERIALIZE_CONTEXT}): User | @{PENDING_REF} {\n        if (value?.__ref !== undefined) {\n            return ctx.getOrDefer(value.__ref);\n        }\n        if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n            throw new @{DESERIALIZE_ERROR}([\n                {\n                    field: '_root',\n                    message: 'User.deserializeWithContext: expected an object'\n                }\n            ]);\n        }\n        const obj = value as Record<string, unknown>;\n        const errors: Array<{\n            field: string;\n            message: string;\n        }> = [];\n        const knownKeys = new Set(['__type', '__id', '__ref', 'id', 'email', 'name', 'age']);\n        for (const key of Object.keys(obj)) {\n            if (!knownKeys.has(key)) {\n                errors.push({\n                    field: key,\n                    message: 'unknown field'\n                });\n            }\n        }\n        if (!('id' in obj)) {\n            errors.push({\n                field: 'id',\n                message: 'missing required field'\n            });\n        }\n        if (!('email' in obj)) {\n            errors.push({\n                field: 'email',\n                message: 'missing required field'\n            });\n        }\n        if (errors.length > 0) {\n            throw new @{DESERIALIZE_ERROR}(errors);\n        }\n        const instance = Object.create(User.prototype) as User;\n        if (obj.__id !== undefined) {\n            ctx.register(obj.__id as number, instance);\n        }\n        ctx.trackForFreeze(instance);\n        {\n            const __raw_id = obj['id'] as number;\n            instance.id = __raw_id;\n        }\n        {\n            const __raw_email = obj['email'] as string;\n            instance.email = __raw_email;\n        }\n        if ('name' in obj && obj['name'] !== undefined) {\n            const __raw_name = obj['name'] as string;\n            instance.name = __raw_name;\n        } else {\n            instance.name = \"guest\";\n        }\n        if ('age' in obj && obj['age'] !== undefined) {\n            const __raw_age = obj['age'] as number;\n            instance.age = __raw_age;\n        }\n        if (errors.length > 0) {\n            throw new @{DESERIALIZE_ERROR}(errors);\n        }\n        return instance;\n    }\n\n    static validateField<K extends keyof User>(\n        field: K,\n        value: User[K]\n    ): Array<{\n        field: string;\n        message: string;\n    }> {\n        return [];\n    }\n\n    static validateFields(partial: Partial<User>): Array<{\n        field: string;\n        message: string;\n    }> {\n        return [];\n    }\n\n    static hasShape(obj: unknown): boolean {\n        if (typeof obj !== 'object' || obj === null || Array.isArray(obj)) {\n            return false;\n        }\n        const o = obj as Record<string, unknown>;\n        return 'id' in o && 'email' in o;\n    }\n\n    static is(obj: unknown): obj is User {\n        if (obj instanceof User) {\n            return true;\n        }\n        if (!User.hasShape(obj)) {\n            return false;\n        }\n        const result = User.deserialize(obj);\n        return Result.isOk(result);\n    }\n}\n\n// Usage:\nconst result = User.deserialize('{\"id\":1,\"email\":\"test@example.com\"}');\nif (Result.isOk(result)) {\n    const user = result.value;\n} else {\n    console.error(result.error); // [{ field: \"email\", message: \"must be a valid email\" }]\n}"
      }
    ],
    "title": "Deserialize Macro Implementation",
    "raw": "# Deserialize Macro Implementation\n\nThe `Deserialize` macro generates JSON deserialization methods with **cycle and\nforward-reference support**, plus comprehensive runtime validation. This enables\nsafe parsing of complex JSON structures including circular references.\n\n## Generated Output\n\n| Type | Generated Code | Description |\n|------|----------------|-------------|\n| Class | `classNameDeserialize(input)` + `static deserialize(input)` | Standalone function + static factory method |\n| Enum | `enumNameDeserialize(input)`, `enumNameDeserializeWithContext(data)`, `enumNameIs(value)` | Standalone functions |\n| Interface | `interfaceNameDeserialize(input)`, etc. | Standalone functions |\n| Type Alias | `typeNameDeserialize(input)`, etc. | Standalone functions |\n\n## Return Type\n\nAll public deserialization methods return `Result<T, Array<{ field: string; message: string }>>`:\n\n- `Result.ok(value)` - Successfully deserialized value\n- `Result.err(errors)` - Array of validation errors with field names and messages\n\n## Cycle/Forward-Reference Support\n\nUses deferred patching to handle references:\n\n1. When encountering `{ \"__ref\": id }`, returns a `PendingRef` marker\n2. Continues deserializing other fields\n3. After all objects are created, `ctx.applyPatches()` resolves all pending references\n\nReferences only apply to object-shaped, serializable values. The generator avoids probing for\n`__ref` on primitive-like fields (including literal unions and `T | null` where `T` is primitive-like),\nand it parses `Date` / `Date | null` from ISO strings without treating them as references.\n\n## Validation\n\nThe macro supports 30+ validators via `@serde(validate(...))`:\n\n### String Validators\n- `email`, `url`, `uuid` - Format validation\n- `minLength(n)`, `maxLength(n)`, `length(n)` - Length constraints\n- `pattern(\"regex\")` - Regular expression matching\n- `nonEmpty`, `trimmed`, `lowercase`, `uppercase` - String properties\n\n### Number Validators\n- `gt(n)`, `gte(n)`, `lt(n)`, `lte(n)`, `between(min, max)` - Range checks\n- `int`, `positive`, `nonNegative`, `finite` - Number properties\n\n### Array Validators\n- `minItems(n)`, `maxItems(n)`, `itemsCount(n)` - Collection size\n\n### Date Validators\n- `validDate`, `afterDate(\"ISO\")`, `beforeDate(\"ISO\")` - Date validation\n\n## Field-Level Options\n\nThe `@serde` decorator supports:\n\n- `skip` / `skipDeserializing` - Exclude field from deserialization\n- `rename = \"jsonKey\"` - Read from different JSON property\n- `default` / `default = expr` - Use default value if missing\n- `flatten` - Read fields from parent object level\n- `validate(...)` - Apply validators\n\n## Container-Level Options\n\n- `denyUnknownFields` - Error on unrecognized JSON properties\n- `renameAll = \"camelCase\"` - Apply naming convention to all fields\n\n## Union Type Deserialization\n\nUnion types are deserialized based on their member types:\n\n### Literal Unions\nFor unions of literal values (`\"A\" | \"B\" | 123`), the value is validated against\nthe allowed literals directly.\n\n### Primitive Unions\nFor unions containing primitive types (`string | number`), the deserializer uses\n`typeof` checks to validate the value type. No `__type` discriminator is needed.\n\n### Class/Interface Unions\nFor unions of serializable types (`User | Admin`), the deserializer requires a\n`__type` field in the JSON to dispatch to the correct type's `deserializeWithContext` method.\n\n### Generic Type Parameters\nFor generic unions like `type Result<T> = T | Error`, the generic type parameter `T`\nis passed through as-is since its concrete type is only known at the call site.\n\n### Mixed Unions\nMixed unions (e.g., `string | Date | User`) check in order:\n1. Literal values\n2. Primitives (via `typeof`)\n3. Date (via `instanceof` or ISO string parsing)\n4. Serializable types (via `__type` dispatch)\n5. Generic type parameters (pass-through)\n\n## Example\n\n```typescript\n/** @derive(Deserialize) @serde({ denyUnknownFields: true }) */\nclass User {\n    id: number;\n\n    /** @serde({ validate: { email: true, maxLength: 255 } }) */\n    email: string;\n\n    /** @serde({ default: \"guest\" }) */\n    name: string;\n\n    /** @serde({ validate: { positive: true } }) */\n    age?: number;\n}\n```\n\nGenerated output:\n\n```typescript\nimport { DeserializeContext } from 'macroforge/serde';\nimport { DeserializeError } from 'macroforge/serde';\nimport type { DeserializeOptions } from 'macroforge/serde';\nimport { PendingRef } from 'macroforge/serde';\n\n/** @serde({ denyUnknownFields: true }) */\nclass User {\n    id: number;\n\n    email: string;\n\n    name: string;\n\n    age?: number;\n\n    constructor(props: {\n        id: number;\n        email: string;\n        name?: string;\n        age?: number;\n    }) {\n        this.id = props.id;\n        this.email = props.email;\n        this.name = props.name as string;\n        this.age = props.age as number;\n    }\n\n    /**\n     * Deserializes input to an instance of this class.\n     * Automatically detects whether input is a JSON string or object.\n     * @param input - JSON string or object to deserialize\n     * @param opts - Optional deserialization options\n     * @returns Result containing the deserialized instance or validation errors\n     */\n    static deserialize(\n        input: unknown,\n        opts?: @{DESERIALIZE_OPTIONS}\n    ): Result<\n        User,\n        Array<{\n            field: string;\n            message: string;\n        }>\n    > {\n        try {\n            // Auto-detect: if string, parse as JSON first\n            const data = typeof input === 'string' ? JSON.parse(input) : input;\n\n            const ctx = @{DESERIALIZE_CONTEXT}.create();\n            const resultOrRef = User.deserializeWithContext(data, ctx);\n            if (@{PENDING_REF}.is(resultOrRef)) {\n                return Result.err([\n                    {\n                        field: '_root',\n                        message: 'User.deserialize: root cannot be a forward reference'\n                    }\n                ]);\n            }\n            ctx.applyPatches();\n            if (opts?.freeze) {\n                ctx.freezeAll();\n            }\n            return Result.ok(resultOrRef);\n        } catch (e) {\n            if (e instanceof @{DESERIALIZE_ERROR}) {\n                return Result.err(e.errors);\n            }\n            const message = e instanceof Error ? e.message : String(e);\n            return Result.err([\n                {\n                    field: '_root',\n                    message\n                }\n            ]);\n        }\n    }\n\n    /** @internal */\n    static deserializeWithContext(value: any, ctx: @{DESERIALIZE_CONTEXT}): User | @{PENDING_REF} {\n        if (value?.__ref !== undefined) {\n            return ctx.getOrDefer(value.__ref);\n        }\n        if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n            throw new @{DESERIALIZE_ERROR}([\n                {\n                    field: '_root',\n                    message: 'User.deserializeWithContext: expected an object'\n                }\n            ]);\n        }\n        const obj = value as Record<string, unknown>;\n        const errors: Array<{\n            field: string;\n            message: string;\n        }> = [];\n        const knownKeys = new Set(['__type', '__id', '__ref', 'id', 'email', 'name', 'age']);\n        for (const key of Object.keys(obj)) {\n            if (!knownKeys.has(key)) {\n                errors.push({\n                    field: key,\n                    message: 'unknown field'\n                });\n            }\n        }\n        if (!('id' in obj)) {\n            errors.push({\n                field: 'id',\n                message: 'missing required field'\n            });\n        }\n        if (!('email' in obj)) {\n            errors.push({\n                field: 'email',\n                message: 'missing required field'\n            });\n        }\n        if (errors.length > 0) {\n            throw new @{DESERIALIZE_ERROR}(errors);\n        }\n        const instance = Object.create(User.prototype) as User;\n        if (obj.__id !== undefined) {\n            ctx.register(obj.__id as number, instance);\n        }\n        ctx.trackForFreeze(instance);\n        {\n            const __raw_id = obj['id'] as number;\n            instance.id = __raw_id;\n        }\n        {\n            const __raw_email = obj['email'] as string;\n            instance.email = __raw_email;\n        }\n        if ('name' in obj && obj['name'] !== undefined) {\n            const __raw_name = obj['name'] as string;\n            instance.name = __raw_name;\n        } else {\n            instance.name = \"guest\";\n        }\n        if ('age' in obj && obj['age'] !== undefined) {\n            const __raw_age = obj['age'] as number;\n            instance.age = __raw_age;\n        }\n        if (errors.length > 0) {\n            throw new @{DESERIALIZE_ERROR}(errors);\n        }\n        return instance;\n    }\n\n    static validateField<K extends keyof User>(\n        field: K,\n        value: User[K]\n    ): Array<{\n        field: string;\n        message: string;\n    }> {\n        return [];\n    }\n\n    static validateFields(partial: Partial<User>): Array<{\n        field: string;\n        message: string;\n    }> {\n        return [];\n    }\n\n    static hasShape(obj: unknown): boolean {\n        if (typeof obj !== 'object' || obj === null || Array.isArray(obj)) {\n            return false;\n        }\n        const o = obj as Record<string, unknown>;\n        return 'id' in o && 'email' in o;\n    }\n\n    static is(obj: unknown): obj is User {\n        if (obj instanceof User) {\n            return true;\n        }\n        if (!User.hasShape(obj)) {\n            return false;\n        }\n        const result = User.deserialize(obj);\n        return Result.isOk(result);\n    }\n}\n\n// Usage:\nconst result = User.deserialize('{\"id\":1,\"email\":\"test@example.com\"}');\nif (Result.isOk(result)) {\n    const user = result.value;\n} else {\n    console.error(result.error); // [{ field: \"email\", message: \"must be a valid email\" }]\n}\n```\n\n## Required Imports\n\nThe generated code automatically imports:\n- `DeserializeContext`, `DeserializeError`, `PendingRef` from `macroforge/serde`"
  },
  "serialize": {
    "name": "Serialize",
    "slug": "serialize",
    "description": "The `Serialize` macro generates JSON serialization methods with **cycle detection**\nand object identity tracking. This enables serialization of complex object graphs\nincluding circular references.",
    "generatedOutput": "| Type | Generated Code | Description |\n|------|----------------|-------------|\n| Class | `classNameSerialize(value)` + `static serialize(value)` | Standalone function + static wrapper method |\n| Enum | `enumNameSerialize(value)`, `enumNameSerializeWithContext` | Standalone functions |\n| Interface | `interfaceNameSerialize(value)`, etc. | Standalone functions |\n| Type Alias | `typeNameSerialize(value)`, etc. | Standalone functions |",
    "fieldOptions": "The `@serde` decorator supports:\n\n- `skip` / `skipSerializing` - Exclude field from serialization\n- `rename = \"jsonKey\"` - Use different JSON property name\n- `flatten` - Merge nested object's fields into parent",
    "example": "```typescript\n/** @derive(Serialize) */\nclass User {\n    id: number;\n\n    /** @serde({ rename: \"userName\" }) */\n    name: string;\n\n    /** @serde({ skipSerializing: true }) */\n    password: string;\n\n    /** @serde({ flatten: true }) */\n    metadata: UserMetadata;\n}\n```\n\nGenerated output:\n\n```typescript\nimport { SerializeContext } from 'macroforge/serde';\n\nclass User {\n    id: number;\n\n    name: string;\n\n    password: string;\n\n    metadata: UserMetadata;\n    /** Serializes a value to a JSON string.\n@param value - The value to serialize\n@returns JSON string representation with cycle detection metadata  */\n\n    static serialize(value: User): string {\n        return userSerialize(value);\n    }\n    /** @internal Serializes with an existing context for nested/cyclic object graphs.\n@param value - The value to serialize\n@param ctx - The serialization context  */\n\n    static serializeWithContext(value: User, ctx: @{SERIALIZE_CONTEXT}): Record<string, unknown> {\n        return userSerializeWithContext(value, ctx);\n    }\n}\n\n/** Serializes a value to a JSON string.\n@param value - The value to serialize\n@returns JSON string representation with cycle detection metadata */ export function userSerialize(\n    value: User\n): string {\n    const ctx = @{SERIALIZE_CONTEXT}.create();\n    return JSON.stringify(userSerializeWithContext(value, ctx));\n} /** @internal Serializes with an existing context for nested/cyclic object graphs.\n@param value - The value to serialize\n@param ctx - The serialization context */\nexport function userSerializeWithContext(\n    value: User,\n    ctx: SerializeContext\n): Record<string, unknown> {\n    const existingId = ctx.getId(value);\n    if (existingId !== undefined) {\n        return { __ref: existingId };\n    }\n    const __id = ctx.register(value);\n    const result: Record<string, unknown> = { __type: 'User', __id };\n    result['id'] = value.id;\n    result['userName'] = value.name;\n    {\n        const __flattened = userMetadataSerializeWithContext(value.metadata, ctx);\n        const { __type: _, __id: __, ...rest } = __flattened as any;\n        Object.assign(result, rest);\n    }\n    return result;\n}\n```",
    "exampleCode": [
      {
        "lang": "typescript",
        "code": "/** @derive(Serialize) */\nclass User {\n    id: number;\n\n    /** @serde({ rename: \"userName\" }) */\n    name: string;\n\n    /** @serde({ skipSerializing: true }) */\n    password: string;\n\n    /** @serde({ flatten: true }) */\n    metadata: UserMetadata;\n}",
        "rawCode": "/** @derive(Serialize) */\nclass User {\n    id: number;\n\n    /** @serde({ rename: \"userName\" }) */\n    name: string;\n\n    /** @serde({ skipSerializing: true }) */\n    password: string;\n\n    /** @serde({ flatten: true }) */\n    metadata: UserMetadata;\n}"
      },
      {
        "lang": "typescript",
        "code": "import { SerializeContext } from 'macroforge/serde';\n\nclass User {\n    id: number;\n\n    name: string;\n\n    password: string;\n\n    metadata: UserMetadata;\n    /** Serializes a value to a JSON string.\n@param value - The value to serialize\n@returns JSON string representation with cycle detection metadata  */\n\n    static serialize(value: User): string {\n        return userSerialize(value);\n    }\n    /** @internal Serializes with an existing context for nested/cyclic object graphs.\n@param value - The value to serialize\n@param ctx - The serialization context  */\n\n    static serializeWithContext(value: User, ctx: @{SERIALIZE_CONTEXT}): Record<string, unknown> {\n        return userSerializeWithContext(value, ctx);\n    }\n}\n\n/** Serializes a value to a JSON string.\n@param value - The value to serialize\n@returns JSON string representation with cycle detection metadata */ export function userSerialize(\n    value: User\n): string {\n    const ctx = @{SERIALIZE_CONTEXT}.create();\n    return JSON.stringify(userSerializeWithContext(value, ctx));\n} /** @internal Serializes with an existing context for nested/cyclic object graphs.\n@param value - The value to serialize\n@param ctx - The serialization context */\nexport function userSerializeWithContext(\n    value: User,\n    ctx: SerializeContext\n): Record<string, unknown> {\n    const existingId = ctx.getId(value);\n    if (existingId !== undefined) {\n        return { __ref: existingId };\n    }\n    const __id = ctx.register(value);\n    const result: Record<string, unknown> = { __type: 'User', __id };\n    result['id'] = value.id;\n    result['userName'] = value.name;\n    {\n        const __flattened = userMetadataSerializeWithContext(value.metadata, ctx);\n        const { __type: _, __id: __, ...rest } = __flattened as any;\n        Object.assign(result, rest);\n    }\n    return result;\n}",
        "rawCode": "import { SerializeContext } from 'macroforge/serde';\n\nclass User {\n    id: number;\n\n    name: string;\n\n    password: string;\n\n    metadata: UserMetadata;\n    /** Serializes a value to a JSON string.\n@param value - The value to serialize\n@returns JSON string representation with cycle detection metadata  */\n\n    static serialize(value: User): string {\n        return userSerialize(value);\n    }\n    /** @internal Serializes with an existing context for nested/cyclic object graphs.\n@param value - The value to serialize\n@param ctx - The serialization context  */\n\n    static serializeWithContext(value: User, ctx: @{SERIALIZE_CONTEXT}): Record<string, unknown> {\n        return userSerializeWithContext(value, ctx);\n    }\n}\n\n/** Serializes a value to a JSON string.\n@param value - The value to serialize\n@returns JSON string representation with cycle detection metadata */ export function userSerialize(\n    value: User\n): string {\n    const ctx = @{SERIALIZE_CONTEXT}.create();\n    return JSON.stringify(userSerializeWithContext(value, ctx));\n} /** @internal Serializes with an existing context for nested/cyclic object graphs.\n@param value - The value to serialize\n@param ctx - The serialization context */\nexport function userSerializeWithContext(\n    value: User,\n    ctx: SerializeContext\n): Record<string, unknown> {\n    const existingId = ctx.getId(value);\n    if (existingId !== undefined) {\n        return { __ref: existingId };\n    }\n    const __id = ctx.register(value);\n    const result: Record<string, unknown> = { __type: 'User', __id };\n    result['id'] = value.id;\n    result['userName'] = value.name;\n    {\n        const __flattened = userMetadataSerializeWithContext(value.metadata, ctx);\n        const { __type: _, __id: __, ...rest } = __flattened as any;\n        Object.assign(result, rest);\n    }\n    return result;\n}"
      }
    ],
    "title": "Serialize Macro Implementation",
    "raw": "# Serialize Macro Implementation\n\nThe `Serialize` macro generates JSON serialization methods with **cycle detection**\nand object identity tracking. This enables serialization of complex object graphs\nincluding circular references.\n\n## Generated Methods\n\n| Type | Generated Code | Description |\n|------|----------------|-------------|\n| Class | `classNameSerialize(value)` + `static serialize(value)` | Standalone function + static wrapper method |\n| Enum | `enumNameSerialize(value)`, `enumNameSerializeWithContext` | Standalone functions |\n| Interface | `interfaceNameSerialize(value)`, etc. | Standalone functions |\n| Type Alias | `typeNameSerialize(value)`, etc. | Standalone functions |\n\n## Cycle Detection Protocol\n\nThe generated code handles circular references using `__id` and `__ref` markers:\n\n```json\n{\n    \"__type\": \"User\",\n    \"__id\": 1,\n    \"name\": \"Alice\",\n    \"friend\": { \"__ref\": 2 }  // Reference to object with __id: 2\n}\n```\n\nWhen an object is serialized:\n1. Check if it's already been serialized (has an `__id`)\n2. If so, return `{ \"__ref\": existingId }` instead\n3. Otherwise, register the object and serialize its fields\n\n## Type-Specific Serialization\n\n| Type | Serialization Strategy |\n|------|------------------------|\n| Primitives | Direct value |\n| `Date` | `toISOString()` |\n| Arrays | For primitive-like element types, pass through; for `Date`/`Date | null`, map to ISO strings; otherwise map and call `SerializeWithContext(ctx)` when available |\n| `Map<K,V>` | For primitive-like values, `Object.fromEntries(map.entries())`; for `Date`/`Date | null`, convert to ISO strings; otherwise call `SerializeWithContext(ctx)` per value when available |\n| `Set<T>` | Convert to array; element handling matches `Array<T>` |\n| Nullable | Include `null` explicitly; for primitive-like and `Date` unions the generator avoids runtime `SerializeWithContext` checks |\n| Objects | Call `SerializeWithContext(ctx)` if available (to support user-defined implementations) |\n\nNote: the generator specializes some code paths based on the declared TypeScript type to\navoid runtime feature detection on primitives and literal unions.\n\n## Field-Level Options\n\nThe `@serde` decorator supports:\n\n- `skip` / `skipSerializing` - Exclude field from serialization\n- `rename = \"jsonKey\"` - Use different JSON property name\n- `flatten` - Merge nested object's fields into parent\n\n## Example\n\n```typescript\n/** @derive(Serialize) */\nclass User {\n    id: number;\n\n    /** @serde({ rename: \"userName\" }) */\n    name: string;\n\n    /** @serde({ skipSerializing: true }) */\n    password: string;\n\n    /** @serde({ flatten: true }) */\n    metadata: UserMetadata;\n}\n```\n\nGenerated output:\n\n```typescript\nimport { SerializeContext } from 'macroforge/serde';\n\nclass User {\n    id: number;\n\n    name: string;\n\n    password: string;\n\n    metadata: UserMetadata;\n    /** Serializes a value to a JSON string.\n@param value - The value to serialize\n@returns JSON string representation with cycle detection metadata  */\n\n    static serialize(value: User): string {\n        return userSerialize(value);\n    }\n    /** @internal Serializes with an existing context for nested/cyclic object graphs.\n@param value - The value to serialize\n@param ctx - The serialization context  */\n\n    static serializeWithContext(value: User, ctx: @{SERIALIZE_CONTEXT}): Record<string, unknown> {\n        return userSerializeWithContext(value, ctx);\n    }\n}\n\n/** Serializes a value to a JSON string.\n@param value - The value to serialize\n@returns JSON string representation with cycle detection metadata */ export function userSerialize(\n    value: User\n): string {\n    const ctx = @{SERIALIZE_CONTEXT}.create();\n    return JSON.stringify(userSerializeWithContext(value, ctx));\n} /** @internal Serializes with an existing context for nested/cyclic object graphs.\n@param value - The value to serialize\n@param ctx - The serialization context */\nexport function userSerializeWithContext(\n    value: User,\n    ctx: SerializeContext\n): Record<string, unknown> {\n    const existingId = ctx.getId(value);\n    if (existingId !== undefined) {\n        return { __ref: existingId };\n    }\n    const __id = ctx.register(value);\n    const result: Record<string, unknown> = { __type: 'User', __id };\n    result['id'] = value.id;\n    result['userName'] = value.name;\n    {\n        const __flattened = userMetadataSerializeWithContext(value.metadata, ctx);\n        const { __type: _, __id: __, ...rest } = __flattened as any;\n        Object.assign(result, rest);\n    }\n    return result;\n}\n```\n\n## Required Import\n\nThe generated code automatically imports `SerializeContext` from `macroforge/serde`."
  },
  "debug": {
    "name": "Debug",
    "slug": "debug",
    "description": "The `Debug` macro generates a human-readable `toString()` method for\nTypeScript classes, interfaces, enums, and type aliases.",
    "generatedOutput": "**Classes**: Generates a standalone function `classNameToString(value)` and a static wrapper\nmethod `static toString(value)` returning a string like `\"ClassName { field1: value1, field2: value2 }\"`.\n\n**Enums**: Generates a standalone function `enumNameToString(value)` that performs\nreverse lookup on numeric enums.\n\n**Interfaces**: Generates a standalone function `interfaceNameToString(value)`.\n\n**Type Aliases**: Generates a standalone function using JSON.stringify for\ncomplex types, or field enumeration for object types.",
    "fieldOptions": "The `@debug` decorator supports:\n\n- `skip` - Exclude the field from debug output\n- `rename = \"label\"` - Use a custom label instead of the field name",
    "example": "```typescript\n/** @derive(Debug) */\nclass User {\n    /** @debug({ rename: \"id\" }) */\n    userId: number;\n\n    /** @debug({ skip: true }) */\n    password: string;\n\n    email: string;\n}\n```\n\nGenerated output:\n\n```typescript\nclass User {\n    userId: number;\n\n    password: string;\n\n    email: string;\n\n    static toString(value: User): string {\n        return userToString(value);\n    }\n}\n\nexport function userToString(value: User): string {\n    const parts: string[] = [];\n    parts.push('id: ' + value.userId);\n    parts.push('email: ' + value.email);\n    return 'User { ' + parts.join(', ') + ' }';\n}\n```",
    "exampleCode": [
      {
        "lang": "typescript",
        "code": "/** @derive(Debug) */\nclass User {\n    /** @debug({ rename: \"id\" }) */\n    userId: number;\n\n    /** @debug({ skip: true }) */\n    password: string;\n\n    email: string;\n}",
        "rawCode": "/** @derive(Debug) */\nclass User {\n    /** @debug({ rename: \"id\" }) */\n    userId: number;\n\n    /** @debug({ skip: true }) */\n    password: string;\n\n    email: string;\n}"
      },
      {
        "lang": "typescript",
        "code": "class User {\n    userId: number;\n\n    password: string;\n\n    email: string;\n\n    static toString(value: User): string {\n        return userToString(value);\n    }\n}\n\nexport function userToString(value: User): string {\n    const parts: string[] = [];\n    parts.push('id: ' + value.userId);\n    parts.push('email: ' + value.email);\n    return 'User { ' + parts.join(', ') + ' }';\n}",
        "rawCode": "class User {\n    userId: number;\n\n    password: string;\n\n    email: string;\n\n    static toString(value: User): string {\n        return userToString(value);\n    }\n}\n\nexport function userToString(value: User): string {\n    const parts: string[] = [];\n    parts.push('id: ' + value.userId);\n    parts.push('email: ' + value.email);\n    return 'User { ' + parts.join(', ') + ' }';\n}"
      }
    ],
    "title": "Debug Macro Implementation",
    "raw": "# Debug Macro Implementation\n\nThe `Debug` macro generates a human-readable `toString()` method for\nTypeScript classes, interfaces, enums, and type aliases.\n\n## Generated Output\n\n**Classes**: Generates a standalone function `classNameToString(value)` and a static wrapper\nmethod `static toString(value)` returning a string like `\"ClassName { field1: value1, field2: value2 }\"`.\n\n**Enums**: Generates a standalone function `enumNameToString(value)` that performs\nreverse lookup on numeric enums.\n\n**Interfaces**: Generates a standalone function `interfaceNameToString(value)`.\n\n**Type Aliases**: Generates a standalone function using JSON.stringify for\ncomplex types, or field enumeration for object types.\n\n\n## Field-Level Options\n\nThe `@debug` decorator supports:\n\n- `skip` - Exclude the field from debug output\n- `rename = \"label\"` - Use a custom label instead of the field name\n\n## Example\n\n```typescript\n/** @derive(Debug) */\nclass User {\n    /** @debug({ rename: \"id\" }) */\n    userId: number;\n\n    /** @debug({ skip: true }) */\n    password: string;\n\n    email: string;\n}\n```\n\nGenerated output:\n\n```typescript\nclass User {\n    userId: number;\n\n    password: string;\n\n    email: string;\n\n    static toString(value: User): string {\n        return userToString(value);\n    }\n}\n\nexport function userToString(value: User): string {\n    const parts: string[] = [];\n    parts.push('id: ' + value.userId);\n    parts.push('email: ' + value.email);\n    return 'User { ' + parts.join(', ') + ' }';\n}\n```"
  },
  "clone": {
    "name": "Clone",
    "slug": "clone",
    "description": "The `Clone` macro generates a `clone()` method for deep copying objects.\nThis is analogous to Rust's `Clone` trait, providing a way to create\nindependent copies of values.",
    "generatedOutput": "| Type | Generated Code | Description |\n|------|----------------|-------------|\n| Class | `classNameClone(value)` + `static clone(value)` | Standalone function + static wrapper method |\n| Enum | `enumNameClone(value: EnumName): EnumName` | Standalone function (enums are primitives, returns value as-is) |\n| Interface | `interfaceNameClone(value: InterfaceName): InterfaceName` | Standalone function creating a new object literal |\n| Type Alias | `typeNameClone(value: TypeName): TypeName` | Standalone function with spread copy for objects |",
    "fieldOptions": "",
    "example": "```typescript\n/** @derive(Clone) */\nclass Point {\n    x: number;\n    y: number;\n}\n```\n\nGenerated output:\n\n```typescript\nclass Point {\n    x: number;\n    y: number;\n\n    static clone(value: Point): Point {\n        return pointClone(value);\n    }\n}\n\nexport function pointClone(value: Point): Point {\n    const cloned = Object.create(Object.getPrototypeOf(value));\n    cloned.x = value.x;\n    cloned.y = value.y;\n    return cloned;\n}\n```",
    "exampleCode": [
      {
        "lang": "typescript",
        "code": "/** @derive(Clone) */\nclass Point {\n    x: number;\n    y: number;\n}",
        "rawCode": "/** @derive(Clone) */\nclass Point {\n    x: number;\n    y: number;\n}"
      },
      {
        "lang": "typescript",
        "code": "class Point {\n    x: number;\n    y: number;\n\n    static clone(value: Point): Point {\n        return pointClone(value);\n    }\n}\n\nexport function pointClone(value: Point): Point {\n    const cloned = Object.create(Object.getPrototypeOf(value));\n    cloned.x = value.x;\n    cloned.y = value.y;\n    return cloned;\n}",
        "rawCode": "class Point {\n    x: number;\n    y: number;\n\n    static clone(value: Point): Point {\n        return pointClone(value);\n    }\n}\n\nexport function pointClone(value: Point): Point {\n    const cloned = Object.create(Object.getPrototypeOf(value));\n    cloned.x = value.x;\n    cloned.y = value.y;\n    return cloned;\n}"
      }
    ],
    "title": "Clone Macro Implementation",
    "raw": "# Clone Macro Implementation\n\nThe `Clone` macro generates a `clone()` method for deep copying objects.\nThis is analogous to Rust's `Clone` trait, providing a way to create\nindependent copies of values.\n\n## Generated Output\n\n| Type | Generated Code | Description |\n|------|----------------|-------------|\n| Class | `classNameClone(value)` + `static clone(value)` | Standalone function + static wrapper method |\n| Enum | `enumNameClone(value: EnumName): EnumName` | Standalone function (enums are primitives, returns value as-is) |\n| Interface | `interfaceNameClone(value: InterfaceName): InterfaceName` | Standalone function creating a new object literal |\n| Type Alias | `typeNameClone(value: TypeName): TypeName` | Standalone function with spread copy for objects |\n\n\n## Cloning Strategy\n\nThe generated clone performs a **shallow copy** of all fields:\n\n- **Primitives** (`string`, `number`, `boolean`): Copied by value\n- **Objects**: Reference is copied (not deep cloned)\n- **Arrays**: Reference is copied (not deep cloned)\n\nFor deep cloning of nested objects, those objects should also derive `Clone`\nand the caller should clone them explicitly.\n\n## Example\n\n```typescript\n/** @derive(Clone) */\nclass Point {\n    x: number;\n    y: number;\n}\n```\n\nGenerated output:\n\n```typescript\nclass Point {\n    x: number;\n    y: number;\n\n    static clone(value: Point): Point {\n        return pointClone(value);\n    }\n}\n\nexport function pointClone(value: Point): Point {\n    const cloned = Object.create(Object.getPrototypeOf(value));\n    cloned.x = value.x;\n    cloned.y = value.y;\n    return cloned;\n}\n```\n\n## Implementation Notes\n\n- **Classes**: Uses `Object.create(Object.getPrototypeOf(value))` to preserve\n  the prototype chain, ensuring `instanceof` checks work correctly\n- **Enums**: Simply returns the value (enums are primitives in TypeScript)\n- **Interfaces/Type Aliases**: Creates new object literals with spread operator\n  for union/tuple types, or field-by-field copy for object types"
  },
  "partial_ord": {
    "name": "PartialOrd",
    "slug": "partial-ord",
    "description": "The `PartialOrd` macro generates a `compareTo()` method for **partial ordering**\ncomparison. This is analogous to Rust's `PartialOrd` trait, enabling comparison\nbetween values where some pairs may be incomparable.",
    "generatedOutput": "| Type | Generated Code | Description |\n|------|----------------|-------------|\n| Class | `classNamePartialCompare(a, b)` + `static compareTo(a, b)` | Standalone function + static wrapper method |\n| Enum | `enumNamePartialCompare(a: EnumName, b: EnumName): Option<number>` | Standalone function returning Option |\n| Interface | `interfaceNamePartialCompare(a: InterfaceName, b: InterfaceName): Option<number>` | Standalone function with Option |\n| Type Alias | `typeNamePartialCompare(a: TypeName, b: TypeName): Option<number>` | Standalone function with Option |",
    "fieldOptions": "The `@ord` decorator supports:\n\n- `skip` - Exclude the field from ordering comparison",
    "example": "```typescript\n/** @derive(PartialOrd) */\nclass Temperature {\n    value: number | null;\n    unit: string;\n}\n```\n\nGenerated output:\n\n```typescript\nclass Temperature {\n    value: number | null;\n    unit: string;\n\n    static compareTo(a: Temperature, b: Temperature): number | null {\n        return temperaturePartialCompare(a, b);\n    }\n}\n\nexport function temperaturePartialCompare(a: Temperature, b: Temperature): number | null {\n    if (a === b) return 0;\n    const cmp0 = (() => {\n        if (typeof (a.value as any)?.compareTo === 'function') {\n            const optResult = (a.value as any).compareTo(b.value);\n            return optResult === null ? null : optResult;\n        }\n        return a.value === b.value ? 0 : null;\n    })();\n    if (cmp0 === null) return null;\n    if (cmp0 !== 0) return cmp0;\n    const cmp1 = a.unit.localeCompare(b.unit);\n    if (cmp1 === null) return null;\n    if (cmp1 !== 0) return cmp1;\n    return 0;\n}\n```",
    "exampleCode": [
      {
        "lang": "typescript",
        "code": "/** @derive(PartialOrd) */\nclass Temperature {\n    value: number | null;\n    unit: string;\n}",
        "rawCode": "/** @derive(PartialOrd) */\nclass Temperature {\n    value: number | null;\n    unit: string;\n}"
      },
      {
        "lang": "typescript",
        "code": "class Temperature {\n    value: number | null;\n    unit: string;\n\n    static compareTo(a: Temperature, b: Temperature): number | null {\n        return temperaturePartialCompare(a, b);\n    }\n}\n\nexport function temperaturePartialCompare(a: Temperature, b: Temperature): number | null {\n    if (a === b) return 0;\n    const cmp0 = (() => {\n        if (typeof (a.value as any)?.compareTo === 'function') {\n            const optResult = (a.value as any).compareTo(b.value);\n            return optResult === null ? null : optResult;\n        }\n        return a.value === b.value ? 0 : null;\n    })();\n    if (cmp0 === null) return null;\n    if (cmp0 !== 0) return cmp0;\n    const cmp1 = a.unit.localeCompare(b.unit);\n    if (cmp1 === null) return null;\n    if (cmp1 !== 0) return cmp1;\n    return 0;\n}",
        "rawCode": "class Temperature {\n    value: number | null;\n    unit: string;\n\n    static compareTo(a: Temperature, b: Temperature): number | null {\n        return temperaturePartialCompare(a, b);\n    }\n}\n\nexport function temperaturePartialCompare(a: Temperature, b: Temperature): number | null {\n    if (a === b) return 0;\n    const cmp0 = (() => {\n        if (typeof (a.value as any)?.compareTo === 'function') {\n            const optResult = (a.value as any).compareTo(b.value);\n            return optResult === null ? null : optResult;\n        }\n        return a.value === b.value ? 0 : null;\n    })();\n    if (cmp0 === null) return null;\n    if (cmp0 !== 0) return cmp0;\n    const cmp1 = a.unit.localeCompare(b.unit);\n    if (cmp1 === null) return null;\n    if (cmp1 !== 0) return cmp1;\n    return 0;\n}"
      }
    ],
    "title": "PartialOrd Macro Implementation",
    "raw": "# PartialOrd Macro Implementation\n\nThe `PartialOrd` macro generates a `compareTo()` method for **partial ordering**\ncomparison. This is analogous to Rust's `PartialOrd` trait, enabling comparison\nbetween values where some pairs may be incomparable.\n\n## Generated Output\n\n| Type | Generated Code | Description |\n|------|----------------|-------------|\n| Class | `classNamePartialCompare(a, b)` + `static compareTo(a, b)` | Standalone function + static wrapper method |\n| Enum | `enumNamePartialCompare(a: EnumName, b: EnumName): Option<number>` | Standalone function returning Option |\n| Interface | `interfaceNamePartialCompare(a: InterfaceName, b: InterfaceName): Option<number>` | Standalone function with Option |\n| Type Alias | `typeNamePartialCompare(a: TypeName, b: TypeName): Option<number>` | Standalone function with Option |\n\n## Return Values\n\nUnlike `Ord`, `PartialOrd` returns an `Option<number>` to handle incomparable values:\n\n- **Option.some(-1)**: `a` is less than `b`\n- **Option.some(0)**: `a` is equal to `b`\n- **Option.some(1)**: `a` is greater than `b`\n- **Option.none()**: Values are incomparable\n\n## When to Use PartialOrd vs Ord\n\n- **PartialOrd**: When some values may not be comparable\n  - Example: Floating-point NaN values\n  - Example: Mixed-type unions\n  - Example: Type mismatches between objects\n\n- **Ord**: When all values are guaranteed comparable (total ordering)\n\n## Comparison Strategy\n\nFields are compared **lexicographically** in declaration order:\n\n1. Compare first field\n2. If incomparable, return `Option.none()`\n3. If not equal, return that result wrapped in `Option.some()`\n4. Otherwise, compare next field\n5. Continue until a difference is found or all fields are equal\n\n## Type-Specific Comparisons\n\n| Type | Comparison Method |\n|------|-------------------|\n| `number`/`bigint` | Direct comparison, returns some() |\n| `string` | `localeCompare()` wrapped in some() |\n| `boolean` | false < true, wrapped in some() |\n| null/undefined | Returns none() for mismatched nullability |\n| Arrays | Lexicographic, propagates none() on incomparable elements |\n| `Date` | Timestamp comparison, none() if invalid |\n| Objects | Unwraps nested Option from compareTo() |\n\n## Field-Level Options\n\nThe `@ord` decorator supports:\n\n- `skip` - Exclude the field from ordering comparison\n\n## Example\n\n```typescript\n/** @derive(PartialOrd) */\nclass Temperature {\n    value: number | null;\n    unit: string;\n}\n```\n\nGenerated output:\n\n```typescript\nclass Temperature {\n    value: number | null;\n    unit: string;\n\n    static compareTo(a: Temperature, b: Temperature): number | null {\n        return temperaturePartialCompare(a, b);\n    }\n}\n\nexport function temperaturePartialCompare(a: Temperature, b: Temperature): number | null {\n    if (a === b) return 0;\n    const cmp0 = (() => {\n        if (typeof (a.value as any)?.compareTo === 'function') {\n            const optResult = (a.value as any).compareTo(b.value);\n            return optResult === null ? null : optResult;\n        }\n        return a.value === b.value ? 0 : null;\n    })();\n    if (cmp0 === null) return null;\n    if (cmp0 !== 0) return cmp0;\n    const cmp1 = a.unit.localeCompare(b.unit);\n    if (cmp1 === null) return null;\n    if (cmp1 !== 0) return cmp1;\n    return 0;\n}\n```\n\n## Return Type\n\nThe generated functions return `number | null` where `null` indicates incomparable values."
  },
  "hash": {
    "name": "Hash",
    "slug": "hash",
    "description": "The `Hash` macro generates a `hashCode()` method for computing numeric hash codes.\nThis is analogous to Rust's `Hash` trait and Java's `hashCode()` method, enabling\nobjects to be used as keys in hash-based collections.",
    "generatedOutput": "| Type | Generated Code | Description |\n|------|----------------|-------------|\n| Class | `classNameHashCode(value)` + `static hashCode(value)` | Standalone function + static wrapper method |\n| Enum | `enumNameHashCode(value: EnumName): number` | Standalone function hashing by enum value |\n| Interface | `interfaceNameHashCode(value: InterfaceName): number` | Standalone function computing hash |\n| Type Alias | `typeNameHashCode(value: TypeName): number` | Standalone function computing hash |",
    "fieldOptions": "The `@hash` decorator supports:\n\n- `skip` - Exclude the field from hash calculation",
    "example": "```typescript\n/** @derive(Hash, PartialEq) */\nclass User {\n    id: number;\n    name: string;\n\n    /** @hash({ skip: true }) */\n    cachedScore: number;\n}\n```\n\nGenerated output:\n\n```typescript\nclass User {\n    id: number;\n    name: string;\n\n    cachedScore: number;\n\n    static hashCode(value: User): number {\n        return userHashCode(value);\n    }\n\n    static equals(a: User, b: User): boolean {\n        return userEquals(a, b);\n    }\n}\n\nexport function userHashCode(value: User): number {\n    let hash = 17;\n    hash =\n        (hash * 31 +\n            (Number.isInteger(value.id)\n                ? value.id | 0\n                : value.id\n                      .toString()\n                      .split('')\n                      .reduce((h, c) => (h * 31 + c.charCodeAt(0)) | 0, 0))) |\n        0;\n    hash =\n        (hash * 31 +\n            (value.name ?? '').split('').reduce((h, c) => (h * 31 + c.charCodeAt(0)) | 0, 0)) |\n        0;\n    return hash;\n}\n\nexport function userEquals(a: User, b: User): boolean {\n    if (a === b) return true;\n    return a.id === b.id && a.name === b.name && a.cachedScore === b.cachedScore;\n}\n```",
    "exampleCode": [
      {
        "lang": "typescript",
        "code": "/** @derive(Hash, PartialEq) */\nclass User {\n    id: number;\n    name: string;\n\n    /** @hash({ skip: true }) */\n    cachedScore: number;\n}",
        "rawCode": "/** @derive(Hash, PartialEq) */\nclass User {\n    id: number;\n    name: string;\n\n    /** @hash({ skip: true }) */\n    cachedScore: number;\n}"
      },
      {
        "lang": "typescript",
        "code": "class User {\n    id: number;\n    name: string;\n\n    cachedScore: number;\n\n    static hashCode(value: User): number {\n        return userHashCode(value);\n    }\n\n    static equals(a: User, b: User): boolean {\n        return userEquals(a, b);\n    }\n}\n\nexport function userHashCode(value: User): number {\n    let hash = 17;\n    hash =\n        (hash * 31 +\n            (Number.isInteger(value.id)\n                ? value.id | 0\n                : value.id\n                      .toString()\n                      .split('')\n                      .reduce((h, c) => (h * 31 + c.charCodeAt(0)) | 0, 0))) |\n        0;\n    hash =\n        (hash * 31 +\n            (value.name ?? '').split('').reduce((h, c) => (h * 31 + c.charCodeAt(0)) | 0, 0)) |\n        0;\n    return hash;\n}\n\nexport function userEquals(a: User, b: User): boolean {\n    if (a === b) return true;\n    return a.id === b.id && a.name === b.name && a.cachedScore === b.cachedScore;\n}",
        "rawCode": "class User {\n    id: number;\n    name: string;\n\n    cachedScore: number;\n\n    static hashCode(value: User): number {\n        return userHashCode(value);\n    }\n\n    static equals(a: User, b: User): boolean {\n        return userEquals(a, b);\n    }\n}\n\nexport function userHashCode(value: User): number {\n    let hash = 17;\n    hash =\n        (hash * 31 +\n            (Number.isInteger(value.id)\n                ? value.id | 0\n                : value.id\n                      .toString()\n                      .split('')\n                      .reduce((h, c) => (h * 31 + c.charCodeAt(0)) | 0, 0))) |\n        0;\n    hash =\n        (hash * 31 +\n            (value.name ?? '').split('').reduce((h, c) => (h * 31 + c.charCodeAt(0)) | 0, 0)) |\n        0;\n    return hash;\n}\n\nexport function userEquals(a: User, b: User): boolean {\n    if (a === b) return true;\n    return a.id === b.id && a.name === b.name && a.cachedScore === b.cachedScore;\n}"
      }
    ],
    "title": "Hash Macro Implementation",
    "raw": "# Hash Macro Implementation\n\nThe `Hash` macro generates a `hashCode()` method for computing numeric hash codes.\nThis is analogous to Rust's `Hash` trait and Java's `hashCode()` method, enabling\nobjects to be used as keys in hash-based collections.\n\n## Generated Output\n\n| Type | Generated Code | Description |\n|------|----------------|-------------|\n| Class | `classNameHashCode(value)` + `static hashCode(value)` | Standalone function + static wrapper method |\n| Enum | `enumNameHashCode(value: EnumName): number` | Standalone function hashing by enum value |\n| Interface | `interfaceNameHashCode(value: InterfaceName): number` | Standalone function computing hash |\n| Type Alias | `typeNameHashCode(value: TypeName): number` | Standalone function computing hash |\n\n\n## Hash Algorithm\n\nUses the standard polynomial rolling hash algorithm:\n\n```text\nhash = 17  // Initial seed\nfor each field:\n    hash = (hash * 31 + fieldHash) | 0  // Bitwise OR keeps it 32-bit integer\n```\n\nThis algorithm is consistent with Java's `Objects.hash()` implementation.\n\n## Type-Specific Hashing\n\n| Type | Hash Strategy |\n|------|---------------|\n| `number` | Integer: direct value; Float: string hash of decimal |\n| `bigint` | String hash of decimal representation |\n| `string` | Character-by-character polynomial hash |\n| `boolean` | 1231 for true, 1237 for false (Java convention) |\n| `Date` | `getTime()` timestamp |\n| Arrays | Element-by-element hash combination |\n| `Map` | Entry-by-entry key+value hash |\n| `Set` | Element-by-element hash |\n| Objects | Calls `hashCode()` if available, else JSON string hash |\n\n## Field-Level Options\n\nThe `@hash` decorator supports:\n\n- `skip` - Exclude the field from hash calculation\n\n## Example\n\n```typescript\n/** @derive(Hash, PartialEq) */\nclass User {\n    id: number;\n    name: string;\n\n    /** @hash({ skip: true }) */\n    cachedScore: number;\n}\n```\n\nGenerated output:\n\n```typescript\nclass User {\n    id: number;\n    name: string;\n\n    cachedScore: number;\n\n    static hashCode(value: User): number {\n        return userHashCode(value);\n    }\n\n    static equals(a: User, b: User): boolean {\n        return userEquals(a, b);\n    }\n}\n\nexport function userHashCode(value: User): number {\n    let hash = 17;\n    hash =\n        (hash * 31 +\n            (Number.isInteger(value.id)\n                ? value.id | 0\n                : value.id\n                      .toString()\n                      .split('')\n                      .reduce((h, c) => (h * 31 + c.charCodeAt(0)) | 0, 0))) |\n        0;\n    hash =\n        (hash * 31 +\n            (value.name ?? '').split('').reduce((h, c) => (h * 31 + c.charCodeAt(0)) | 0, 0)) |\n        0;\n    return hash;\n}\n\nexport function userEquals(a: User, b: User): boolean {\n    if (a === b) return true;\n    return a.id === b.id && a.name === b.name && a.cachedScore === b.cachedScore;\n}\n```\n\n## Hash Contract\n\nObjects that are equal (`PartialEq`) should produce the same hash code.\nWhen using `@hash(skip)`, ensure the same fields are skipped in both\n`Hash` and `PartialEq` to maintain this contract."
  },
  "ord": {
    "name": "Ord",
    "slug": "ord",
    "description": "The `Ord` macro generates a `compareTo()` method for **total ordering** comparison.\nThis is analogous to Rust's `Ord` trait, enabling objects to be sorted and\ncompared with a guaranteed ordering relationship.",
    "generatedOutput": "| Type | Generated Code | Description |\n|------|----------------|-------------|\n| Class | `classNameCompare(a, b)` + `static compareTo(a, b)` | Standalone function + static wrapper method |\n| Enum | `enumNameCompare(a: EnumName, b: EnumName): number` | Standalone function comparing enum values |\n| Interface | `interfaceNameCompare(a: InterfaceName, b: InterfaceName): number` | Standalone function comparing fields |\n| Type Alias | `typeNameCompare(a: TypeName, b: TypeName): number` | Standalone function with type-appropriate comparison |",
    "fieldOptions": "The `@ord` decorator supports:\n\n- `skip` - Exclude the field from ordering comparison",
    "example": "```typescript\n/** @derive(Ord) */\nclass Version {\n    major: number;\n    minor: number;\n    patch: number;\n}\n```\n\nGenerated output:\n\n```typescript\nclass Version {\n    major: number;\n    minor: number;\n    patch: number;\n\n    static compareTo(a: Version, b: Version): number {\n        return versionCompare(a, b);\n    }\n}\n\nexport function versionCompare(a: Version, b: Version): number {\n    if (a === b) return 0;\n    const cmp0 = a.major < b.major ? -1 : a.major > b.major ? 1 : 0;\n    if (cmp0 !== 0) return cmp0;\n    const cmp1 = a.minor < b.minor ? -1 : a.minor > b.minor ? 1 : 0;\n    if (cmp1 !== 0) return cmp1;\n    const cmp2 = a.patch < b.patch ? -1 : a.patch > b.patch ? 1 : 0;\n    if (cmp2 !== 0) return cmp2;\n    return 0;\n}\n```",
    "exampleCode": [
      {
        "lang": "typescript",
        "code": "/** @derive(Ord) */\nclass Version {\n    major: number;\n    minor: number;\n    patch: number;\n}",
        "rawCode": "/** @derive(Ord) */\nclass Version {\n    major: number;\n    minor: number;\n    patch: number;\n}"
      },
      {
        "lang": "typescript",
        "code": "class Version {\n    major: number;\n    minor: number;\n    patch: number;\n\n    static compareTo(a: Version, b: Version): number {\n        return versionCompare(a, b);\n    }\n}\n\nexport function versionCompare(a: Version, b: Version): number {\n    if (a === b) return 0;\n    const cmp0 = a.major < b.major ? -1 : a.major > b.major ? 1 : 0;\n    if (cmp0 !== 0) return cmp0;\n    const cmp1 = a.minor < b.minor ? -1 : a.minor > b.minor ? 1 : 0;\n    if (cmp1 !== 0) return cmp1;\n    const cmp2 = a.patch < b.patch ? -1 : a.patch > b.patch ? 1 : 0;\n    if (cmp2 !== 0) return cmp2;\n    return 0;\n}",
        "rawCode": "class Version {\n    major: number;\n    minor: number;\n    patch: number;\n\n    static compareTo(a: Version, b: Version): number {\n        return versionCompare(a, b);\n    }\n}\n\nexport function versionCompare(a: Version, b: Version): number {\n    if (a === b) return 0;\n    const cmp0 = a.major < b.major ? -1 : a.major > b.major ? 1 : 0;\n    if (cmp0 !== 0) return cmp0;\n    const cmp1 = a.minor < b.minor ? -1 : a.minor > b.minor ? 1 : 0;\n    if (cmp1 !== 0) return cmp1;\n    const cmp2 = a.patch < b.patch ? -1 : a.patch > b.patch ? 1 : 0;\n    if (cmp2 !== 0) return cmp2;\n    return 0;\n}"
      }
    ],
    "title": "Ord Macro Implementation",
    "raw": "# Ord Macro Implementation\n\nThe `Ord` macro generates a `compareTo()` method for **total ordering** comparison.\nThis is analogous to Rust's `Ord` trait, enabling objects to be sorted and\ncompared with a guaranteed ordering relationship.\n\n## Generated Output\n\n| Type | Generated Code | Description |\n|------|----------------|-------------|\n| Class | `classNameCompare(a, b)` + `static compareTo(a, b)` | Standalone function + static wrapper method |\n| Enum | `enumNameCompare(a: EnumName, b: EnumName): number` | Standalone function comparing enum values |\n| Interface | `interfaceNameCompare(a: InterfaceName, b: InterfaceName): number` | Standalone function comparing fields |\n| Type Alias | `typeNameCompare(a: TypeName, b: TypeName): number` | Standalone function with type-appropriate comparison |\n\n\n## Return Values\n\nUnlike `PartialOrd`, `Ord` provides **total ordering** - every pair of values\ncan be compared:\n\n- **-1**: `a` is less than `b`\n- **0**: `a` is equal to `b`\n- **1**: `a` is greater than `b`\n\nThe function **never returns null** - all values must be comparable.\n\n## Comparison Strategy\n\nFields are compared **lexicographically** in declaration order:\n\n1. Compare first field\n2. If not equal, return that result\n3. Otherwise, compare next field\n4. Continue until a difference is found or all fields are equal\n\n## Type-Specific Comparisons\n\n| Type | Comparison Method |\n|------|-------------------|\n| `number`/`bigint` | Direct `<` and `>` comparison |\n| `string` | `localeCompare()` (clamped to -1, 0, 1) |\n| `boolean` | false < true |\n| Arrays | Lexicographic element-by-element |\n| `Date` | `getTime()` timestamp comparison |\n| Objects | Calls `compareTo()` if available, else 0 |\n\n## Field-Level Options\n\nThe `@ord` decorator supports:\n\n- `skip` - Exclude the field from ordering comparison\n\n## Example\n\n```typescript\n/** @derive(Ord) */\nclass Version {\n    major: number;\n    minor: number;\n    patch: number;\n}\n```\n\nGenerated output:\n\n```typescript\nclass Version {\n    major: number;\n    minor: number;\n    patch: number;\n\n    static compareTo(a: Version, b: Version): number {\n        return versionCompare(a, b);\n    }\n}\n\nexport function versionCompare(a: Version, b: Version): number {\n    if (a === b) return 0;\n    const cmp0 = a.major < b.major ? -1 : a.major > b.major ? 1 : 0;\n    if (cmp0 !== 0) return cmp0;\n    const cmp1 = a.minor < b.minor ? -1 : a.minor > b.minor ? 1 : 0;\n    if (cmp1 !== 0) return cmp1;\n    const cmp2 = a.patch < b.patch ? -1 : a.patch > b.patch ? 1 : 0;\n    if (cmp2 !== 0) return cmp2;\n    return 0;\n}\n```\n\n## Ord vs PartialOrd\n\n- Use **Ord** when all values are comparable (total ordering)\n- Use **PartialOrd** when some values may be incomparable (returns `Option<number>`)"
  },
  "partial_eq": {
    "name": "PartialEq",
    "slug": "partial-eq",
    "description": "The `PartialEq` macro generates an `equals()` method for field-by-field\nstructural equality comparison. This is analogous to Rust's `PartialEq` trait,\nenabling value-based equality semantics instead of reference equality.",
    "generatedOutput": "| Type | Generated Code | Description |\n|------|----------------|-------------|\n| Class | `classNameEquals(a, b)` + `static equals(a, b)` | Standalone function + static wrapper method |\n| Enum | `enumNameEquals(a: EnumName, b: EnumName): boolean` | Standalone function using strict equality |\n| Interface | `interfaceNameEquals(a: InterfaceName, b: InterfaceName): boolean` | Standalone function comparing fields |\n| Type Alias | `typeNameEquals(a: TypeName, b: TypeName): boolean` | Standalone function with type-appropriate comparison |",
    "fieldOptions": "The `@partialEq` decorator supports:\n\n- `skip` - Exclude the field from equality comparison",
    "example": "```typescript\n/** @derive(PartialEq, Hash) */\nclass User {\n    id: number;\n    name: string;\n\n    /** @partialEq({ skip: true }) @hash({ skip: true }) */\n    cachedScore: number;\n}\n```\n\nGenerated output:\n\n```typescript\nclass User {\n    id: number;\n    name: string;\n\n    cachedScore: number;\n\n    static equals(a: User, b: User): boolean {\n        return userEquals(a, b);\n    }\n\n    static hashCode(value: User): number {\n        return userHashCode(value);\n    }\n}\n\nexport function userEquals(a: User, b: User): boolean {\n    if (a === b) return true;\n    return a.id === b.id && a.name === b.name;\n}\n\nexport function userHashCode(value: User): number {\n    let hash = 17;\n    hash =\n        (hash * 31 +\n            (Number.isInteger(value.id)\n                ? value.id | 0\n                : value.id\n                      .toString()\n                      .split('')\n                      .reduce((h, c) => (h * 31 + c.charCodeAt(0)) | 0, 0))) |\n        0;\n    hash =\n        (hash * 31 +\n            (value.name ?? '').split('').reduce((h, c) => (h * 31 + c.charCodeAt(0)) | 0, 0)) |\n        0;\n    return hash;\n}\n```",
    "exampleCode": [
      {
        "lang": "typescript",
        "code": "/** @derive(PartialEq, Hash) */\nclass User {\n    id: number;\n    name: string;\n\n    /** @partialEq({ skip: true }) @hash({ skip: true }) */\n    cachedScore: number;\n}",
        "rawCode": "/** @derive(PartialEq, Hash) */\nclass User {\n    id: number;\n    name: string;\n\n    /** @partialEq({ skip: true }) @hash({ skip: true }) */\n    cachedScore: number;\n}"
      },
      {
        "lang": "typescript",
        "code": "class User {\n    id: number;\n    name: string;\n\n    cachedScore: number;\n\n    static equals(a: User, b: User): boolean {\n        return userEquals(a, b);\n    }\n\n    static hashCode(value: User): number {\n        return userHashCode(value);\n    }\n}\n\nexport function userEquals(a: User, b: User): boolean {\n    if (a === b) return true;\n    return a.id === b.id && a.name === b.name;\n}\n\nexport function userHashCode(value: User): number {\n    let hash = 17;\n    hash =\n        (hash * 31 +\n            (Number.isInteger(value.id)\n                ? value.id | 0\n                : value.id\n                      .toString()\n                      .split('')\n                      .reduce((h, c) => (h * 31 + c.charCodeAt(0)) | 0, 0))) |\n        0;\n    hash =\n        (hash * 31 +\n            (value.name ?? '').split('').reduce((h, c) => (h * 31 + c.charCodeAt(0)) | 0, 0)) |\n        0;\n    return hash;\n}",
        "rawCode": "class User {\n    id: number;\n    name: string;\n\n    cachedScore: number;\n\n    static equals(a: User, b: User): boolean {\n        return userEquals(a, b);\n    }\n\n    static hashCode(value: User): number {\n        return userHashCode(value);\n    }\n}\n\nexport function userEquals(a: User, b: User): boolean {\n    if (a === b) return true;\n    return a.id === b.id && a.name === b.name;\n}\n\nexport function userHashCode(value: User): number {\n    let hash = 17;\n    hash =\n        (hash * 31 +\n            (Number.isInteger(value.id)\n                ? value.id | 0\n                : value.id\n                      .toString()\n                      .split('')\n                      .reduce((h, c) => (h * 31 + c.charCodeAt(0)) | 0, 0))) |\n        0;\n    hash =\n        (hash * 31 +\n            (value.name ?? '').split('').reduce((h, c) => (h * 31 + c.charCodeAt(0)) | 0, 0)) |\n        0;\n    return hash;\n}"
      }
    ],
    "title": "PartialEq Macro Implementation",
    "raw": "# PartialEq Macro Implementation\n\nThe `PartialEq` macro generates an `equals()` method for field-by-field\nstructural equality comparison. This is analogous to Rust's `PartialEq` trait,\nenabling value-based equality semantics instead of reference equality.\n\n## Generated Output\n\n| Type | Generated Code | Description |\n|------|----------------|-------------|\n| Class | `classNameEquals(a, b)` + `static equals(a, b)` | Standalone function + static wrapper method |\n| Enum | `enumNameEquals(a: EnumName, b: EnumName): boolean` | Standalone function using strict equality |\n| Interface | `interfaceNameEquals(a: InterfaceName, b: InterfaceName): boolean` | Standalone function comparing fields |\n| Type Alias | `typeNameEquals(a: TypeName, b: TypeName): boolean` | Standalone function with type-appropriate comparison |\n\n## Comparison Strategy\n\nThe generated equality check:\n\n1. **Identity check**: `a === b` returns true immediately\n2. **Field comparison**: Compares each non-skipped field\n\n## Type-Specific Comparisons\n\n| Type | Comparison Method |\n|------|-------------------|\n| Primitives | Strict equality (`===`) |\n| Arrays | Length + element-by-element (recursive) |\n| `Date` | `getTime()` comparison |\n| `Map` | Size + entry-by-entry comparison |\n| `Set` | Size + membership check |\n| Objects | Calls `equals()` if available, else `===` |\n\n## Field-Level Options\n\nThe `@partialEq` decorator supports:\n\n- `skip` - Exclude the field from equality comparison\n\n## Example\n\n```typescript\n/** @derive(PartialEq, Hash) */\nclass User {\n    id: number;\n    name: string;\n\n    /** @partialEq({ skip: true }) @hash({ skip: true }) */\n    cachedScore: number;\n}\n```\n\nGenerated output:\n\n```typescript\nclass User {\n    id: number;\n    name: string;\n\n    cachedScore: number;\n\n    static equals(a: User, b: User): boolean {\n        return userEquals(a, b);\n    }\n\n    static hashCode(value: User): number {\n        return userHashCode(value);\n    }\n}\n\nexport function userEquals(a: User, b: User): boolean {\n    if (a === b) return true;\n    return a.id === b.id && a.name === b.name;\n}\n\nexport function userHashCode(value: User): number {\n    let hash = 17;\n    hash =\n        (hash * 31 +\n            (Number.isInteger(value.id)\n                ? value.id | 0\n                : value.id\n                      .toString()\n                      .split('')\n                      .reduce((h, c) => (h * 31 + c.charCodeAt(0)) | 0, 0))) |\n        0;\n    hash =\n        (hash * 31 +\n            (value.name ?? '').split('').reduce((h, c) => (h * 31 + c.charCodeAt(0)) | 0, 0)) |\n        0;\n    return hash;\n}\n```\n\n## Equality Contract\n\nWhen implementing `PartialEq`, consider also implementing `Hash`:\n\n- **Reflexivity**: `a.equals(a)` is always true\n- **Symmetry**: `a.equals(b)` implies `b.equals(a)`\n- **Hash consistency**: Equal objects must have equal hash codes\n\nTo maintain the hash contract, skip the same fields in both `PartialEq` and `Hash`:\n\n```typescript\n/** @derive(PartialEq, Hash) */\nclass User {\n    id: number;\n    name: string;\n\n    /** @partialEq({ skip: true }) @hash({ skip: true }) */\n    cachedScore: number;\n}\n```\n\nGenerated output:\n\n```typescript\nclass User {\n    id: number;\n    name: string;\n\n    cachedScore: number;\n\n    static equals(a: User, b: User): boolean {\n        return userEquals(a, b);\n    }\n\n    static hashCode(value: User): number {\n        return userHashCode(value);\n    }\n}\n\nexport function userEquals(a: User, b: User): boolean {\n    if (a === b) return true;\n    return a.id === b.id && a.name === b.name;\n}\n\nexport function userHashCode(value: User): number {\n    let hash = 17;\n    hash =\n        (hash * 31 +\n            (Number.isInteger(value.id)\n                ? value.id | 0\n                : value.id\n                      .toString()\n                      .split('')\n                      .reduce((h, c) => (h * 31 + c.charCodeAt(0)) | 0, 0))) |\n        0;\n    hash =\n        (hash * 31 +\n            (value.name ?? '').split('').reduce((h, c) => (h * 31 + c.charCodeAt(0)) | 0, 0)) |\n        0;\n    return hash;\n}\n```"
  },
  "default": {
    "name": "Default",
    "slug": "default",
    "description": "The `Default` macro generates a static `defaultValue()` factory method that creates\ninstances with default values. This is analogous to Rust's `Default` trait, providing\na standard way to create \"zero\" or \"empty\" instances of types.",
    "generatedOutput": "| Type | Generated Code | Description |\n|------|----------------|-------------|\n| Class | `static defaultValue(): ClassName` | Static factory method |\n| Enum | `defaultValueEnumName(): EnumName` | Standalone function returning marked variant |\n| Interface | `defaultValueInterfaceName(): InterfaceName` | Standalone function returning object literal |\n| Type Alias | `defaultValueTypeName(): TypeName` | Standalone function with type-appropriate default |",
    "fieldOptions": "The `@default` decorator allows specifying explicit default values:\n\n- `@default(42)` - Use 42 as the default\n- `@default(\"hello\")` - Use \"hello\" as the default\n- `@default([])` - Use empty array as the default\n- `@default({ value: \"test\" })` - Named form for complex values",
    "example": "```typescript\n/** @derive(Default) */\nclass UserSettings {\n    /** @default(\"light\") */\n    theme: string;\n\n    /** @default(10) */\n    pageSize: number;\n\n    notifications: boolean;  // Uses type default: false\n}\n```\n\nGenerated output:\n\n```typescript\nclass UserSettings {\n    theme: string;\n\n    pageSize: number;\n\n    notifications: boolean; // Uses type default: false\n\n    static defaultValue(): UserSettings {\n        const instance = new UserSettings();\n        instance.theme = 'light';\n        instance.pageSize = 10;\n        instance.notifications = false;\n        return instance;\n    }\n}\n```",
    "exampleCode": [
      {
        "lang": "typescript",
        "code": "/** @derive(Default) */\nclass UserSettings {\n    /** @default(\"light\") */\n    theme: string;\n\n    /** @default(10) */\n    pageSize: number;\n\n    notifications: boolean;  // Uses type default: false\n}",
        "rawCode": "/** @derive(Default) */\nclass UserSettings {\n    /** @default(\"light\") */\n    theme: string;\n\n    /** @default(10) */\n    pageSize: number;\n\n    notifications: boolean;  // Uses type default: false\n}"
      },
      {
        "lang": "typescript",
        "code": "class UserSettings {\n    theme: string;\n\n    pageSize: number;\n\n    notifications: boolean; // Uses type default: false\n\n    static defaultValue(): UserSettings {\n        const instance = new UserSettings();\n        instance.theme = 'light';\n        instance.pageSize = 10;\n        instance.notifications = false;\n        return instance;\n    }\n}",
        "rawCode": "class UserSettings {\n    theme: string;\n\n    pageSize: number;\n\n    notifications: boolean; // Uses type default: false\n\n    static defaultValue(): UserSettings {\n        const instance = new UserSettings();\n        instance.theme = 'light';\n        instance.pageSize = 10;\n        instance.notifications = false;\n        return instance;\n    }\n}"
      }
    ],
    "title": "Default Macro Implementation",
    "raw": "# Default Macro Implementation\n\nThe `Default` macro generates a static `defaultValue()` factory method that creates\ninstances with default values. This is analogous to Rust's `Default` trait, providing\na standard way to create \"zero\" or \"empty\" instances of types.\n\n## Generated Output\n\n| Type | Generated Code | Description |\n|------|----------------|-------------|\n| Class | `static defaultValue(): ClassName` | Static factory method |\n| Enum | `defaultValueEnumName(): EnumName` | Standalone function returning marked variant |\n| Interface | `defaultValueInterfaceName(): InterfaceName` | Standalone function returning object literal |\n| Type Alias | `defaultValueTypeName(): TypeName` | Standalone function with type-appropriate default |\n\n\n## Default Values by Type\n\nThe macro uses Rust-like default semantics:\n\n| Type | Default Value |\n|------|---------------|\n| `string` | `\"\"` (empty string) |\n| `number` | `0` |\n| `boolean` | `false` |\n| `bigint` | `0n` |\n| `T[]` | `[]` (empty array) |\n| `Array<T>` | `[]` (empty array) |\n| `Map<K,V>` | `new Map()` |\n| `Set<T>` | `new Set()` |\n| `Date` | `new Date()` (current time) |\n| `T \\| null` | `null` |\n| `CustomType` | `CustomType.defaultValue()` (recursive) |\n\n## Field-Level Options\n\nThe `@default` decorator allows specifying explicit default values:\n\n- `@default(42)` - Use 42 as the default\n- `@default(\"hello\")` - Use \"hello\" as the default\n- `@default([])` - Use empty array as the default\n- `@default({ value: \"test\" })` - Named form for complex values\n\n## Example\n\n```typescript\n/** @derive(Default) */\nclass UserSettings {\n    /** @default(\"light\") */\n    theme: string;\n\n    /** @default(10) */\n    pageSize: number;\n\n    notifications: boolean;  // Uses type default: false\n}\n```\n\nGenerated output:\n\n```typescript\nclass UserSettings {\n    theme: string;\n\n    pageSize: number;\n\n    notifications: boolean; // Uses type default: false\n\n    static defaultValue(): UserSettings {\n        const instance = new UserSettings();\n        instance.theme = 'light';\n        instance.pageSize = 10;\n        instance.notifications = false;\n        return instance;\n    }\n}\n```\n\n## Enum Defaults\n\nFor enums, mark one variant with `@default`:\n\n```typescript\n/** @derive(Default) */\nenum Status {\n    /** @default */\n    Pending,\n    Active,\n    Completed\n}\n```\n\nGenerated output:\n\n```typescript\nenum Status {\n    /** @default */\n    Pending,\n    Active,\n    Completed\n}\n\nexport function statusDefaultValue(): Status {\n    return Status.Pending;\n}\n\nnamespace Status {\n    export const defaultValue = statusDefaultValue;\n}\n```\n\n## Error Handling\n\nThe macro will return an error if:\n\n- A non-primitive field lacks `@default` and has no known default\n- An enum has no variant marked with `@default`\n- A union type has no `@default` on a variant"
  }
}