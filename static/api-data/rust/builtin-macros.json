{
  "debug": {
    "name": "Debug",
    "slug": "debug",
    "description": "The `Debug` macro generates a human-readable `toString()` method for\nTypeScript classes, interfaces, enums, and type aliases.",
    "generatedOutput": "**Classes and Interfaces**: Generates an instance method returning a string\nlike `\"ClassName { field1: value1, field2: value2 }\"`.\n\n**Enums**: Generates a namespace function `toString(value)` that performs\nreverse lookup on numeric enums.\n\n**Type Aliases**: Generates a namespace function using JSON.stringify for\ncomplex types, or field enumeration for object types.",
    "fieldOptions": "The `@debug` decorator supports:\n\n- `skip` - Exclude the field from debug output\n- `rename = \"label\"` - Use a custom label instead of the field name",
    "example": "```typescript\n@derive(Debug)\nclass User {\n    @debug(rename = \"id\")\n    userId: number;\n\n    @debug(skip)\n    password: string;\n\n    email: string;\n}\n\n// Generated:\n// toString(): string {\n//     return \"User { id: \" + this.userId + \", email: \" + this.email + \" }\";\n// }\n```",
    "exampleCode": [
      {
        "lang": "typescript",
        "code": "/** @derive(Debug) */\nclass User {\n    /** @debug({ rename: \"id\" }) */\n    userId: number;\n\n    /** @debug({ skip: true }) */\n    password: string;\n\n    email: string;\n}\n\n// Generated:\n// toString(): string {\n//     return \"User { id: \" + this.userId + \", email: \" + this.email + \" }\";\n// }",
        "rawCode": "@derive(Debug)\nclass User {\n    @debug(rename = \"id\")\n    userId: number;\n\n    @debug(skip)\n    password: string;\n\n    email: string;\n}\n\n// Generated:\n// toString(): string {\n//     return \"User { id: \" + this.userId + \", email: \" + this.email + \" }\";\n// }"
      }
    ],
    "title": "Debug Macro Implementation",
    "raw": "# Debug Macro Implementation\n\nThe `Debug` macro generates a human-readable `toString()` method for\nTypeScript classes, interfaces, enums, and type aliases.\n\n## Generated Output\n\n**Classes and Interfaces**: Generates an instance method returning a string\nlike `\"ClassName { field1: value1, field2: value2 }\"`.\n\n**Enums**: Generates a namespace function `toString(value)` that performs\nreverse lookup on numeric enums.\n\n**Type Aliases**: Generates a namespace function using JSON.stringify for\ncomplex types, or field enumeration for object types.\n\n## Field-Level Options\n\nThe `@debug` decorator supports:\n\n- `skip` - Exclude the field from debug output\n- `rename = \"label\"` - Use a custom label instead of the field name\n\n## Example\n\n```typescript\n@derive(Debug)\nclass User {\n    @debug(rename = \"id\")\n    userId: number;\n\n    @debug(skip)\n    password: string;\n\n    email: string;\n}\n\n// Generated:\n// toString(): string {\n//     return \"User { id: \" + this.userId + \", email: \" + this.email + \" }\";\n// }\n```"
  },
  "clone": {
    "name": "Clone",
    "slug": "clone",
    "description": "The `Clone` macro generates a `clone()` method for deep copying objects.\nThis is analogous to Rust's `Clone` trait, providing a way to create\nindependent copies of values.",
    "generatedOutput": "| Type | Generated Method | Description |\n|------|------------------|-------------|\n| Class | `clone(): ClassName` | Instance method creating a new instance with copied fields |\n| Enum | `EnumName.clone(value)` | Namespace function (enums are primitives, returns value as-is) |\n| Interface | `InterfaceName.clone(self)` | Namespace function creating a new object literal |\n| Type Alias | `TypeName.clone(value)` | Namespace function with spread copy for objects |",
    "fieldOptions": "",
    "example": "```typescript\n@derive(Clone)\nclass Point {\n    x: number;\n    y: number;\n}\n\n// Generated:\n// clone(): Point {\n//     const cloned = Object.create(Object.getPrototypeOf(this));\n//     cloned.x = this.x;\n//     cloned.y = this.y;\n//     return cloned;\n// }\n\nconst p1 = new Point();\nconst p2 = p1.clone(); // Creates a new Point with same values\n```",
    "exampleCode": [
      {
        "lang": "typescript",
        "code": "/** @derive(Clone) */\nclass Point {\n    x: number;\n    y: number;\n}\n\n// Generated:\n// clone(): Point {\n//     const cloned = Object.create(Object.getPrototypeOf(this));\n//     cloned.x = this.x;\n//     cloned.y = this.y;\n//     return cloned;\n// }\n\nconst p1 = new Point();\nconst p2 = p1.clone(); // Creates a new Point with same values",
        "rawCode": "@derive(Clone)\nclass Point {\n    x: number;\n    y: number;\n}\n\n// Generated:\n// clone(): Point {\n//     const cloned = Object.create(Object.getPrototypeOf(this));\n//     cloned.x = this.x;\n//     cloned.y = this.y;\n//     return cloned;\n// }\n\nconst p1 = new Point();\nconst p2 = p1.clone(); // Creates a new Point with same values"
      }
    ],
    "title": "Clone Macro Implementation",
    "raw": "# Clone Macro Implementation\n\nThe `Clone` macro generates a `clone()` method for deep copying objects.\nThis is analogous to Rust's `Clone` trait, providing a way to create\nindependent copies of values.\n\n## Generated Output\n\n| Type | Generated Method | Description |\n|------|------------------|-------------|\n| Class | `clone(): ClassName` | Instance method creating a new instance with copied fields |\n| Enum | `EnumName.clone(value)` | Namespace function (enums are primitives, returns value as-is) |\n| Interface | `InterfaceName.clone(self)` | Namespace function creating a new object literal |\n| Type Alias | `TypeName.clone(value)` | Namespace function with spread copy for objects |\n\n## Cloning Strategy\n\nThe generated clone performs a **shallow copy** of all fields:\n\n- **Primitives** (`string`, `number`, `boolean`): Copied by value\n- **Objects**: Reference is copied (not deep cloned)\n- **Arrays**: Reference is copied (not deep cloned)\n\nFor deep cloning of nested objects, those objects should also derive `Clone`\nand the caller should clone them explicitly.\n\n## Example\n\n```typescript\n@derive(Clone)\nclass Point {\n    x: number;\n    y: number;\n}\n\n// Generated:\n// clone(): Point {\n//     const cloned = Object.create(Object.getPrototypeOf(this));\n//     cloned.x = this.x;\n//     cloned.y = this.y;\n//     return cloned;\n// }\n\nconst p1 = new Point();\nconst p2 = p1.clone(); // Creates a new Point with same values\n```\n\n## Implementation Notes\n\n- **Classes**: Uses `Object.create(Object.getPrototypeOf(this))` to preserve\n  the prototype chain, ensuring `instanceof` checks work correctly\n- **Enums**: Simply returns the value (enums are primitives in TypeScript)\n- **Interfaces/Type Aliases**: Creates new object literals with spread operator\n  for union/tuple types, or field-by-field copy for object types"
  },
  "default": {
    "name": "Default",
    "slug": "default",
    "description": "The `Default` macro generates a static `defaultValue()` factory method that creates\ninstances with default values. This is analogous to Rust's `Default` trait, providing\na standard way to create \"zero\" or \"empty\" instances of types.",
    "generatedOutput": "| Type | Generated Method | Description |\n|------|------------------|-------------|\n| Class | `static defaultValue(): ClassName` | Static factory method |\n| Enum | `EnumName.defaultValue()` | Namespace function returning marked variant |\n| Interface | `InterfaceName.defaultValue()` | Namespace function returning object literal |\n| Type Alias | `TypeName.defaultValue()` | Namespace function with type-appropriate default |",
    "fieldOptions": "The `@default` decorator allows specifying explicit default values:\n\n- `@default(42)` - Use 42 as the default\n- `@default(\"hello\")` - Use \"hello\" as the default\n- `@default([])` - Use empty array as the default\n- `@default({ value: \"test\" })` - Named form for complex values",
    "example": "```typescript\n@derive(Default)\nclass UserSettings {\n    @default(\"light\")\n    theme: string;\n\n    @default(10)\n    pageSize: number;\n\n    notifications: boolean;  // Uses type default: false\n}\n\n// Generated:\n// static defaultValue(): UserSettings {\n//     const instance = new UserSettings();\n//     instance.theme = \"light\";\n//     instance.pageSize = 10;\n//     instance.notifications = false;\n//     return instance;\n// }\n```",
    "exampleCode": [
      {
        "lang": "typescript",
        "code": "/** @derive(Default) */\nclass UserSettings {\n    /** @default({ \"light\" }) */\n    theme: string;\n\n    /** @default({ 10: true }) */\n    pageSize: number;\n\n    notifications: boolean;  // Uses type default: false\n}\n\n// Generated:\n// static defaultValue(): UserSettings {\n//     const instance = new UserSettings();\n//     instance.theme = \"light\";\n//     instance.pageSize = 10;\n//     instance.notifications = false;\n//     return instance;\n// }",
        "rawCode": "@derive(Default)\nclass UserSettings {\n    @default(\"light\")\n    theme: string;\n\n    @default(10)\n    pageSize: number;\n\n    notifications: boolean;  // Uses type default: false\n}\n\n// Generated:\n// static defaultValue(): UserSettings {\n//     const instance = new UserSettings();\n//     instance.theme = \"light\";\n//     instance.pageSize = 10;\n//     instance.notifications = false;\n//     return instance;\n// }"
      }
    ],
    "title": "Default Macro Implementation",
    "raw": "# Default Macro Implementation\n\nThe `Default` macro generates a static `defaultValue()` factory method that creates\ninstances with default values. This is analogous to Rust's `Default` trait, providing\na standard way to create \"zero\" or \"empty\" instances of types.\n\n## Generated Output\n\n| Type | Generated Method | Description |\n|------|------------------|-------------|\n| Class | `static defaultValue(): ClassName` | Static factory method |\n| Enum | `EnumName.defaultValue()` | Namespace function returning marked variant |\n| Interface | `InterfaceName.defaultValue()` | Namespace function returning object literal |\n| Type Alias | `TypeName.defaultValue()` | Namespace function with type-appropriate default |\n\n## Default Values by Type\n\nThe macro uses Rust-like default semantics:\n\n| Type | Default Value |\n|------|---------------|\n| `string` | `\"\"` (empty string) |\n| `number` | `0` |\n| `boolean` | `false` |\n| `bigint` | `0n` |\n| `T[]` | `[]` (empty array) |\n| `Array<T>` | `[]` (empty array) |\n| `Map<K,V>` | `new Map()` |\n| `Set<T>` | `new Set()` |\n| `Date` | `new Date()` (current time) |\n| `T \\| null` | `null` |\n| `CustomType` | `CustomType.defaultValue()` (recursive) |\n\n## Field-Level Options\n\nThe `@default` decorator allows specifying explicit default values:\n\n- `@default(42)` - Use 42 as the default\n- `@default(\"hello\")` - Use \"hello\" as the default\n- `@default([])` - Use empty array as the default\n- `@default({ value: \"test\" })` - Named form for complex values\n\n## Example\n\n```typescript\n@derive(Default)\nclass UserSettings {\n    @default(\"light\")\n    theme: string;\n\n    @default(10)\n    pageSize: number;\n\n    notifications: boolean;  // Uses type default: false\n}\n\n// Generated:\n// static defaultValue(): UserSettings {\n//     const instance = new UserSettings();\n//     instance.theme = \"light\";\n//     instance.pageSize = 10;\n//     instance.notifications = false;\n//     return instance;\n// }\n```\n\n## Enum Defaults\n\nFor enums, mark one variant with `@default`:\n\n```typescript\n@derive(Default)\nenum Status {\n    @default\n    Pending,\n    Active,\n    Completed\n}\n\n// Generated:\n// export namespace Status {\n//     export function defaultValue(): Status {\n//         return Status.Pending;\n//     }\n// }\n```\n\n## Error Handling\n\nThe macro will return an error if:\n\n- A non-primitive field lacks `@default` and has no known default\n- An enum has no variant marked with `@default`\n- A union type has no `@default` on a variant"
  },
  "hash": {
    "name": "Hash",
    "slug": "hash",
    "description": "The `Hash` macro generates a `hashCode()` method for computing numeric hash codes.\nThis is analogous to Rust's `Hash` trait and Java's `hashCode()` method, enabling\nobjects to be used as keys in hash-based collections.",
    "generatedOutput": "| Type | Generated Method | Description |\n|------|------------------|-------------|\n| Class | `hashCode(): number` | Instance method computing hash from all fields |\n| Enum | `EnumName.hashCode(value)` | Namespace function hashing by enum value |\n| Interface | `InterfaceName.hashCode(self)` | Namespace function computing hash |\n| Type Alias | `TypeName.hashCode(value)` | Namespace function computing hash |",
    "fieldOptions": "The `@hash` decorator supports:\n\n- `skip` - Exclude the field from hash calculation",
    "example": "```typescript\n@derive(Hash, PartialEq)\nclass User {\n    id: number;\n    name: string;\n\n    @hash(skip)  // Cached value shouldn't affect hash\n    cachedScore: number;\n}\n\n// Generated:\n// hashCode(): number {\n//     let hash = 17;\n//     hash = (hash * 31 + (Number.isInteger(this.id) ? this.id | 0 : ...)) | 0;\n//     hash = (hash * 31 + (this.name ?? '').split('').reduce(...)) | 0;\n//     return hash;\n// }\n```",
    "exampleCode": [
      {
        "lang": "typescript",
        "code": "/** @derive(Hash, PartialEq) */\nclass User {\n    id: number;\n    name: string;\n\n    @hash(skip)  // Cached value shouldn't affect hash\n    cachedScore: number;\n}\n\n// Generated:\n// hashCode(): number {\n//     let hash = 17;\n//     hash = (hash * 31 + (Number.isInteger(this.id) ? this.id | 0 : ...)) | 0;\n//     hash = (hash * 31 + (this.name ?? '').split('').reduce(...)) | 0;\n//     return hash;\n// }",
        "rawCode": "@derive(Hash, PartialEq)\nclass User {\n    id: number;\n    name: string;\n\n    @hash(skip)  // Cached value shouldn't affect hash\n    cachedScore: number;\n}\n\n// Generated:\n// hashCode(): number {\n//     let hash = 17;\n//     hash = (hash * 31 + (Number.isInteger(this.id) ? this.id | 0 : ...)) | 0;\n//     hash = (hash * 31 + (this.name ?? '').split('').reduce(...)) | 0;\n//     return hash;\n// }"
      }
    ],
    "title": "Hash Macro Implementation",
    "raw": "# Hash Macro Implementation\n\nThe `Hash` macro generates a `hashCode()` method for computing numeric hash codes.\nThis is analogous to Rust's `Hash` trait and Java's `hashCode()` method, enabling\nobjects to be used as keys in hash-based collections.\n\n## Generated Output\n\n| Type | Generated Method | Description |\n|------|------------------|-------------|\n| Class | `hashCode(): number` | Instance method computing hash from all fields |\n| Enum | `EnumName.hashCode(value)` | Namespace function hashing by enum value |\n| Interface | `InterfaceName.hashCode(self)` | Namespace function computing hash |\n| Type Alias | `TypeName.hashCode(value)` | Namespace function computing hash |\n\n## Hash Algorithm\n\nUses the standard polynomial rolling hash algorithm:\n\n```text\nhash = 17  // Initial seed\nfor each field:\n    hash = (hash * 31 + fieldHash) | 0  // Bitwise OR keeps it 32-bit integer\n```\n\nThis algorithm is consistent with Java's `Objects.hash()` implementation.\n\n## Type-Specific Hashing\n\n| Type | Hash Strategy |\n|------|---------------|\n| `number` | Integer: direct value; Float: string hash of decimal |\n| `bigint` | String hash of decimal representation |\n| `string` | Character-by-character polynomial hash |\n| `boolean` | 1231 for true, 1237 for false (Java convention) |\n| `Date` | `getTime()` timestamp |\n| Arrays | Element-by-element hash combination |\n| `Map` | Entry-by-entry key+value hash |\n| `Set` | Element-by-element hash |\n| Objects | Calls `hashCode()` if available, else JSON string hash |\n\n## Field-Level Options\n\nThe `@hash` decorator supports:\n\n- `skip` - Exclude the field from hash calculation\n\n## Example\n\n```typescript\n@derive(Hash, PartialEq)\nclass User {\n    id: number;\n    name: string;\n\n    @hash(skip)  // Cached value shouldn't affect hash\n    cachedScore: number;\n}\n\n// Generated:\n// hashCode(): number {\n//     let hash = 17;\n//     hash = (hash * 31 + (Number.isInteger(this.id) ? this.id | 0 : ...)) | 0;\n//     hash = (hash * 31 + (this.name ?? '').split('').reduce(...)) | 0;\n//     return hash;\n// }\n```\n\n## Hash Contract\n\nObjects that are equal (`PartialEq`) should produce the same hash code.\nWhen using `@hash(skip)`, ensure the same fields are skipped in both\n`Hash` and `PartialEq` to maintain this contract."
  },
  "ord": {
    "name": "Ord",
    "slug": "ord",
    "description": "The `Ord` macro generates a `compareTo()` method for **total ordering** comparison.\nThis is analogous to Rust's `Ord` trait, enabling objects to be sorted and\ncompared with a guaranteed ordering relationship.",
    "generatedOutput": "| Type | Generated Method | Description |\n|------|------------------|-------------|\n| Class | `compareTo(other): number` | Instance method returning -1, 0, or 1 |\n| Enum | `EnumName.compareTo(a, b)` | Namespace function comparing enum values |\n| Interface | `InterfaceName.compareTo(self, other)` | Namespace function comparing fields |\n| Type Alias | `TypeName.compareTo(a, b)` | Namespace function with type-appropriate comparison |",
    "fieldOptions": "The `@ord` decorator supports:\n\n- `skip` - Exclude the field from ordering comparison",
    "example": "```typescript\n@derive(Ord)\nclass Version {\n    major: number;\n    minor: number;\n    patch: number;\n}\n\n// Generated:\n// compareTo(other: Version): number {\n//     if (this === other) return 0;\n//     const typedOther = other;\n//     const cmp0 = this.major < typedOther.major ? -1 : this.major > typedOther.major ? 1 : 0;\n//     if (cmp0 !== 0) return cmp0;\n//     const cmp1 = this.minor < typedOther.minor ? -1 : ...;\n//     if (cmp1 !== 0) return cmp1;\n//     const cmp2 = this.patch < typedOther.patch ? -1 : ...;\n//     if (cmp2 !== 0) return cmp2;\n//     return 0;\n// }\n\n// Usage:\nversions.sort((a, b) => a.compareTo(b));\n```",
    "exampleCode": [
      {
        "lang": "typescript",
        "code": "/** @derive(Ord) */\nclass Version {\n    major: number;\n    minor: number;\n    patch: number;\n}\n\n// Generated:\n// compareTo(other: Version): number {\n//     if (this === other) return 0;\n//     const typedOther = other;\n//     const cmp0 = this.major < typedOther.major ? -1 : this.major > typedOther.major ? 1 : 0;\n//     if (cmp0 !== 0) return cmp0;\n//     const cmp1 = this.minor < typedOther.minor ? -1 : ...;\n//     if (cmp1 !== 0) return cmp1;\n//     const cmp2 = this.patch < typedOther.patch ? -1 : ...;\n//     if (cmp2 !== 0) return cmp2;\n//     return 0;\n// }\n\n// Usage:\nversions.sort((a, b) => a.compareTo(b));",
        "rawCode": "@derive(Ord)\nclass Version {\n    major: number;\n    minor: number;\n    patch: number;\n}\n\n// Generated:\n// compareTo(other: Version): number {\n//     if (this === other) return 0;\n//     const typedOther = other;\n//     const cmp0 = this.major < typedOther.major ? -1 : this.major > typedOther.major ? 1 : 0;\n//     if (cmp0 !== 0) return cmp0;\n//     const cmp1 = this.minor < typedOther.minor ? -1 : ...;\n//     if (cmp1 !== 0) return cmp1;\n//     const cmp2 = this.patch < typedOther.patch ? -1 : ...;\n//     if (cmp2 !== 0) return cmp2;\n//     return 0;\n// }\n\n// Usage:\nversions.sort((a, b) => a.compareTo(b));"
      }
    ],
    "title": "Ord Macro Implementation",
    "raw": "# Ord Macro Implementation\n\nThe `Ord` macro generates a `compareTo()` method for **total ordering** comparison.\nThis is analogous to Rust's `Ord` trait, enabling objects to be sorted and\ncompared with a guaranteed ordering relationship.\n\n## Generated Output\n\n| Type | Generated Method | Description |\n|------|------------------|-------------|\n| Class | `compareTo(other): number` | Instance method returning -1, 0, or 1 |\n| Enum | `EnumName.compareTo(a, b)` | Namespace function comparing enum values |\n| Interface | `InterfaceName.compareTo(self, other)` | Namespace function comparing fields |\n| Type Alias | `TypeName.compareTo(a, b)` | Namespace function with type-appropriate comparison |\n\n## Return Values\n\nUnlike `PartialOrd`, `Ord` provides **total ordering** - every pair of values\ncan be compared:\n\n- **-1**: `this` is less than `other`\n- **0**: `this` is equal to `other`\n- **1**: `this` is greater than `other`\n\nThe method **never returns null** - all values must be comparable.\n\n## Comparison Strategy\n\nFields are compared **lexicographically** in declaration order:\n\n1. Compare first field\n2. If not equal, return that result\n3. Otherwise, compare next field\n4. Continue until a difference is found or all fields are equal\n\n## Type-Specific Comparisons\n\n| Type | Comparison Method |\n|------|-------------------|\n| `number`/`bigint` | Direct `<` and `>` comparison |\n| `string` | `localeCompare()` (clamped to -1, 0, 1) |\n| `boolean` | false < true |\n| Arrays | Lexicographic element-by-element |\n| `Date` | `getTime()` timestamp comparison |\n| Objects | Calls `compareTo()` if available, else 0 |\n\n## Field-Level Options\n\nThe `@ord` decorator supports:\n\n- `skip` - Exclude the field from ordering comparison\n\n## Example\n\n```typescript\n@derive(Ord)\nclass Version {\n    major: number;\n    minor: number;\n    patch: number;\n}\n\n// Generated:\n// compareTo(other: Version): number {\n//     if (this === other) return 0;\n//     const typedOther = other;\n//     const cmp0 = this.major < typedOther.major ? -1 : this.major > typedOther.major ? 1 : 0;\n//     if (cmp0 !== 0) return cmp0;\n//     const cmp1 = this.minor < typedOther.minor ? -1 : ...;\n//     if (cmp1 !== 0) return cmp1;\n//     const cmp2 = this.patch < typedOther.patch ? -1 : ...;\n//     if (cmp2 !== 0) return cmp2;\n//     return 0;\n// }\n\n// Usage:\nversions.sort((a, b) => a.compareTo(b));\n```\n\n## Ord vs PartialOrd\n\n- Use **Ord** when all values are comparable (total ordering)\n- Use **PartialOrd** when some values may be incomparable (returns `Option<number>`)"
  },
  "partial_eq": {
    "name": "PartialEq",
    "slug": "partial-eq",
    "description": "The `PartialEq` macro generates an `equals()` method for field-by-field\nstructural equality comparison. This is analogous to Rust's `PartialEq` trait,\nenabling value-based equality semantics instead of reference equality.",
    "generatedOutput": "| Type | Generated Method | Description |\n|------|------------------|-------------|\n| Class | `equals(other: unknown): boolean` | Instance method with instanceof check |\n| Enum | `EnumName.equals(a, b)` | Namespace function using strict equality |\n| Interface | `InterfaceName.equals(self, other)` | Namespace function comparing fields |\n| Type Alias | `TypeName.equals(a, b)` | Namespace function with type-appropriate comparison |",
    "fieldOptions": "The `@partialEq` decorator supports:\n\n- `skip` - Exclude the field from equality comparison",
    "example": "```typescript\n@derive(PartialEq, Hash)\nclass User {\n    id: number;\n    name: string;\n\n    @partialEq(skip)  // Don't compare cached values\n    @hash(skip)\n    cachedScore: number;\n}\n\n// Generated:\n// equals(other: unknown): boolean {\n//     if (this === other) return true;\n//     if (!(other instanceof User)) return false;\n//     const typedOther = other as User;\n//     return this.id === typedOther.id &&\n//            this.name === typedOther.name;\n// }\n```",
    "exampleCode": [
      {
        "lang": "typescript",
        "code": "/** @derive(PartialEq, Hash) */\nclass User {\n    id: number;\n    name: string;\n\n    @partialEq(skip)  // Don't compare cached values\n    /** @hash({ skip: true }) */\n    cachedScore: number;\n}\n\n// Generated:\n// equals(other: unknown): boolean {\n//     if (this === other) return true;\n//     if (!(other instanceof User)) return false;\n//     const typedOther = other as User;\n//     return this.id === typedOther.id &&\n//            this.name === typedOther.name;\n// }",
        "rawCode": "@derive(PartialEq, Hash)\nclass User {\n    id: number;\n    name: string;\n\n    @partialEq(skip)  // Don't compare cached values\n    @hash(skip)\n    cachedScore: number;\n}\n\n// Generated:\n// equals(other: unknown): boolean {\n//     if (this === other) return true;\n//     if (!(other instanceof User)) return false;\n//     const typedOther = other as User;\n//     return this.id === typedOther.id &&\n//            this.name === typedOther.name;\n// }"
      }
    ],
    "title": "PartialEq Macro Implementation",
    "raw": "# PartialEq Macro Implementation\n\nThe `PartialEq` macro generates an `equals()` method for field-by-field\nstructural equality comparison. This is analogous to Rust's `PartialEq` trait,\nenabling value-based equality semantics instead of reference equality.\n\n## Generated Output\n\n| Type | Generated Method | Description |\n|------|------------------|-------------|\n| Class | `equals(other: unknown): boolean` | Instance method with instanceof check |\n| Enum | `EnumName.equals(a, b)` | Namespace function using strict equality |\n| Interface | `InterfaceName.equals(self, other)` | Namespace function comparing fields |\n| Type Alias | `TypeName.equals(a, b)` | Namespace function with type-appropriate comparison |\n\n## Comparison Strategy\n\nThe generated equality check:\n\n1. **Identity check**: `this === other` returns true immediately\n2. **Type check**: For classes, uses `instanceof`; returns false if wrong type\n3. **Field comparison**: Compares each non-skipped field\n\n## Type-Specific Comparisons\n\n| Type | Comparison Method |\n|------|-------------------|\n| Primitives | Strict equality (`===`) |\n| Arrays | Length + element-by-element (recursive) |\n| `Date` | `getTime()` comparison |\n| `Map` | Size + entry-by-entry comparison |\n| `Set` | Size + membership check |\n| Objects | Calls `equals()` if available, else `===` |\n\n## Field-Level Options\n\nThe `@partialEq` decorator supports:\n\n- `skip` - Exclude the field from equality comparison\n\n## Example\n\n```typescript\n@derive(PartialEq, Hash)\nclass User {\n    id: number;\n    name: string;\n\n    @partialEq(skip)  // Don't compare cached values\n    @hash(skip)\n    cachedScore: number;\n}\n\n// Generated:\n// equals(other: unknown): boolean {\n//     if (this === other) return true;\n//     if (!(other instanceof User)) return false;\n//     const typedOther = other as User;\n//     return this.id === typedOther.id &&\n//            this.name === typedOther.name;\n// }\n```\n\n## Equality Contract\n\nWhen implementing `PartialEq`, consider also implementing `Hash`:\n\n- **Reflexivity**: `a.equals(a)` is always true\n- **Symmetry**: `a.equals(b)` implies `b.equals(a)`\n- **Hash consistency**: Equal objects must have equal hash codes"
  },
  "partial_ord": {
    "name": "PartialOrd",
    "slug": "partial-ord",
    "description": "The `PartialOrd` macro generates a `compareTo()` method for **partial ordering**\ncomparison. This is analogous to Rust's `PartialOrd` trait, enabling comparison\nbetween values where some pairs may be incomparable.",
    "generatedOutput": "| Type | Generated Method | Description |\n|------|------------------|-------------|\n| Class | `compareTo(other): Option<number>` | Instance method with optional result |\n| Enum | `EnumName.compareTo(a, b)` | Namespace function returning Option |\n| Interface | `InterfaceName.compareTo(self, other)` | Namespace function with Option |\n| Type Alias | `TypeName.compareTo(a, b)` | Namespace function with Option |",
    "fieldOptions": "The `@ord` decorator supports:\n\n- `skip` - Exclude the field from ordering comparison",
    "example": "```typescript\n@derive(PartialOrd)\nclass Temperature {\n    value: number | null;  // null represents \"unknown\"\n    unit: string;\n}\n\n// Generated:\n// compareTo(other: unknown): Option<number> {\n//     if (this === other) return Option.some(0);\n//     if (!(other instanceof Temperature)) return Option.none();\n//     const typedOther = other as Temperature;\n//     const cmp0 = ...;  // Compare value field\n//     if (cmp0 === null) return Option.none();\n//     if (cmp0 !== 0) return Option.some(cmp0);\n//     const cmp1 = ...;  // Compare unit field\n//     if (cmp1 === null) return Option.none();\n//     if (cmp1 !== 0) return Option.some(cmp1);\n//     return Option.some(0);\n// }\n```",
    "exampleCode": [
      {
        "lang": "typescript",
        "code": "/** @derive(PartialOrd) */\nclass Temperature {\n    value: number | null;  // null represents \"unknown\"\n    unit: string;\n}\n\n// Generated:\n// compareTo(other: unknown): Option<number> {\n//     if (this === other) return Option.some(0);\n//     if (!(other instanceof Temperature)) return Option.none();\n//     const typedOther = other as Temperature;\n//     const cmp0 = ...;  // Compare value field\n//     if (cmp0 === null) return Option.none();\n//     if (cmp0 !== 0) return Option.some(cmp0);\n//     const cmp1 = ...;  // Compare unit field\n//     if (cmp1 === null) return Option.none();\n//     if (cmp1 !== 0) return Option.some(cmp1);\n//     return Option.some(0);\n// }",
        "rawCode": "@derive(PartialOrd)\nclass Temperature {\n    value: number | null;  // null represents \"unknown\"\n    unit: string;\n}\n\n// Generated:\n// compareTo(other: unknown): Option<number> {\n//     if (this === other) return Option.some(0);\n//     if (!(other instanceof Temperature)) return Option.none();\n//     const typedOther = other as Temperature;\n//     const cmp0 = ...;  // Compare value field\n//     if (cmp0 === null) return Option.none();\n//     if (cmp0 !== 0) return Option.some(cmp0);\n//     const cmp1 = ...;  // Compare unit field\n//     if (cmp1 === null) return Option.none();\n//     if (cmp1 !== 0) return Option.some(cmp1);\n//     return Option.some(0);\n// }"
      }
    ],
    "title": "PartialOrd Macro Implementation",
    "raw": "# PartialOrd Macro Implementation\n\nThe `PartialOrd` macro generates a `compareTo()` method for **partial ordering**\ncomparison. This is analogous to Rust's `PartialOrd` trait, enabling comparison\nbetween values where some pairs may be incomparable.\n\n## Generated Output\n\n| Type | Generated Method | Description |\n|------|------------------|-------------|\n| Class | `compareTo(other): Option<number>` | Instance method with optional result |\n| Enum | `EnumName.compareTo(a, b)` | Namespace function returning Option |\n| Interface | `InterfaceName.compareTo(self, other)` | Namespace function with Option |\n| Type Alias | `TypeName.compareTo(a, b)` | Namespace function with Option |\n\n## Return Values\n\nUnlike `Ord`, `PartialOrd` returns an `Option<number>` to handle incomparable values:\n\n- **Option.some(-1)**: `this` is less than `other`\n- **Option.some(0)**: `this` is equal to `other`\n- **Option.some(1)**: `this` is greater than `other`\n- **Option.none()**: Values are incomparable\n\n## When to Use PartialOrd vs Ord\n\n- **PartialOrd**: When some values may not be comparable\n  - Example: Floating-point NaN values\n  - Example: Mixed-type unions\n  - Example: Type mismatches between objects\n\n- **Ord**: When all values are guaranteed comparable (total ordering)\n\n## Comparison Strategy\n\nFields are compared **lexicographically** in declaration order:\n\n1. Compare first field\n2. If incomparable, return `Option.none()`\n3. If not equal, return that result wrapped in `Option.some()`\n4. Otherwise, compare next field\n5. Continue until a difference is found or all fields are equal\n\n## Type-Specific Comparisons\n\n| Type | Comparison Method |\n|------|-------------------|\n| `number`/`bigint` | Direct comparison, returns some() |\n| `string` | `localeCompare()` wrapped in some() |\n| `boolean` | false < true, wrapped in some() |\n| null/undefined | Returns none() for mismatched nullability |\n| Arrays | Lexicographic, propagates none() on incomparable elements |\n| `Date` | Timestamp comparison, none() if invalid |\n| Objects | Unwraps nested Option from compareTo() |\n\n## Field-Level Options\n\nThe `@ord` decorator supports:\n\n- `skip` - Exclude the field from ordering comparison\n\n## Example\n\n```typescript\n@derive(PartialOrd)\nclass Temperature {\n    value: number | null;  // null represents \"unknown\"\n    unit: string;\n}\n\n// Generated:\n// compareTo(other: unknown): Option<number> {\n//     if (this === other) return Option.some(0);\n//     if (!(other instanceof Temperature)) return Option.none();\n//     const typedOther = other as Temperature;\n//     const cmp0 = ...;  // Compare value field\n//     if (cmp0 === null) return Option.none();\n//     if (cmp0 !== 0) return Option.some(cmp0);\n//     const cmp1 = ...;  // Compare unit field\n//     if (cmp1 === null) return Option.none();\n//     if (cmp1 !== 0) return Option.some(cmp1);\n//     return Option.some(0);\n// }\n```\n\n## Required Import\n\nThe generated code automatically adds an import for `Option` from `macroforge/utils`."
  },
  "serialize": {
    "name": "Serialize",
    "slug": "serialize",
    "description": "The `Serialize` macro generates JSON serialization methods with **cycle detection**\nand object identity tracking. This enables serialization of complex object graphs\nincluding circular references.",
    "generatedOutput": "| Type | Generated Methods | Description |\n|------|-------------------|-------------|\n| Class | `toStringifiedJSON()`, `toObject()`, `__serialize(ctx)` | Instance methods |\n| Enum | `EnumName.toStringifiedJSON(value)`, `__serialize` | Namespace functions |\n| Interface | `InterfaceName.toStringifiedJSON(self)`, etc. | Namespace functions |\n| Type Alias | `TypeName.toStringifiedJSON(value)`, etc. | Namespace functions |",
    "fieldOptions": "The `@serde` decorator supports:\n\n- `skip` / `skip_serializing` - Exclude field from serialization\n- `rename = \"jsonKey\"` - Use different JSON property name\n- `flatten` - Merge nested object's fields into parent",
    "example": "```typescript\n@derive(Serialize)\nclass User {\n    id: number;\n\n    @serde(rename = \"userName\")\n    name: string;\n\n    @serde(skip_serializing)\n    password: string;\n\n    @serde(flatten)\n    metadata: UserMetadata;\n}\n\n// Usage:\nconst user = new User();\nconst json = user.toStringifiedJSON();\n// => '{\"__type\":\"User\",\"__id\":1,\"id\":1,\"userName\":\"Alice\",...}'\n\nconst obj = user.toObject();\n// => { __type: \"User\", __id: 1, id: 1, userName: \"Alice\", ... }\n```",
    "exampleCode": [
      {
        "lang": "typescript",
        "code": "/** @derive(Serialize) */\nclass User {\n    id: number;\n\n    /** @serde({ rename: \"userName\" }) */\n    name: string;\n\n    /** @serde({ skip_serializing: true }) */\n    password: string;\n\n    /** @serde({ flatten: true }) */\n    metadata: UserMetadata;\n}\n\n// Usage:\nconst user = new User();\nconst json = user.toStringifiedJSON();\n// => '{\"__type\":\"User\",\"__id\":1,\"id\":1,\"userName\":\"Alice\",...}'\n\nconst obj = user.toObject();\n// => { __type: \"User\", __id: 1, id: 1, userName: \"Alice\", ... }",
        "rawCode": "@derive(Serialize)\nclass User {\n    id: number;\n\n    @serde(rename = \"userName\")\n    name: string;\n\n    @serde(skip_serializing)\n    password: string;\n\n    @serde(flatten)\n    metadata: UserMetadata;\n}\n\n// Usage:\nconst user = new User();\nconst json = user.toStringifiedJSON();\n// => '{\"__type\":\"User\",\"__id\":1,\"id\":1,\"userName\":\"Alice\",...}'\n\nconst obj = user.toObject();\n// => { __type: \"User\", __id: 1, id: 1, userName: \"Alice\", ... }"
      }
    ],
    "title": "Serialize Macro Implementation",
    "raw": "# Serialize Macro Implementation\n\nThe `Serialize` macro generates JSON serialization methods with **cycle detection**\nand object identity tracking. This enables serialization of complex object graphs\nincluding circular references.\n\n## Generated Methods\n\n| Type | Generated Methods | Description |\n|------|-------------------|-------------|\n| Class | `toStringifiedJSON()`, `toObject()`, `__serialize(ctx)` | Instance methods |\n| Enum | `EnumName.toStringifiedJSON(value)`, `__serialize` | Namespace functions |\n| Interface | `InterfaceName.toStringifiedJSON(self)`, etc. | Namespace functions |\n| Type Alias | `TypeName.toStringifiedJSON(value)`, etc. | Namespace functions |\n\n## Cycle Detection Protocol\n\nThe generated code handles circular references using `__id` and `__ref` markers:\n\n```json\n{\n    \"__type\": \"User\",\n    \"__id\": 1,\n    \"name\": \"Alice\",\n    \"friend\": { \"__ref\": 2 }  // Reference to object with __id: 2\n}\n```\n\nWhen an object is serialized:\n1. Check if it's already been serialized (has an `__id`)\n2. If so, return `{ \"__ref\": existingId }` instead\n3. Otherwise, register the object and serialize its fields\n\n## Type-Specific Serialization\n\n| Type | Serialization Strategy |\n|------|------------------------|\n| Primitives | Direct value |\n| `Date` | `toISOString()` |\n| Arrays | Map with recursive `__serialize` |\n| `Map<K,V>` | `Object.fromEntries()` |\n| `Set<T>` | Convert to array |\n| Nullable | Include `null` explicitly |\n| Objects | Call `__serialize(ctx)` if available |\n\n## Field-Level Options\n\nThe `@serde` decorator supports:\n\n- `skip` / `skip_serializing` - Exclude field from serialization\n- `rename = \"jsonKey\"` - Use different JSON property name\n- `flatten` - Merge nested object's fields into parent\n\n## Example\n\n```typescript\n@derive(Serialize)\nclass User {\n    id: number;\n\n    @serde(rename = \"userName\")\n    name: string;\n\n    @serde(skip_serializing)\n    password: string;\n\n    @serde(flatten)\n    metadata: UserMetadata;\n}\n\n// Usage:\nconst user = new User();\nconst json = user.toStringifiedJSON();\n// => '{\"__type\":\"User\",\"__id\":1,\"id\":1,\"userName\":\"Alice\",...}'\n\nconst obj = user.toObject();\n// => { __type: \"User\", __id: 1, id: 1, userName: \"Alice\", ... }\n```\n\n## Required Import\n\nThe generated code automatically imports `SerializeContext` from `macroforge/serde`."
  },
  "deserialize": {
    "name": "Deserialize",
    "slug": "deserialize",
    "description": "The `Deserialize` macro generates JSON deserialization methods with **cycle and\nforward-reference support**, plus comprehensive runtime validation. This enables\nsafe parsing of complex JSON structures including circular references.",
    "generatedOutput": "| Type | Generated Methods | Description |\n|------|-------------------|-------------|\n| Class | `static fromStringifiedJSON()`, `static fromObject()`, `static __deserialize()` | Static factory methods |\n| Enum | `EnumName.fromStringifiedJSON()`, `__deserialize()` | Namespace functions |\n| Interface | `InterfaceName.fromStringifiedJSON()`, etc. | Namespace functions |\n| Type Alias | `TypeName.fromStringifiedJSON()`, etc. | Namespace functions |",
    "fieldOptions": "- `deny_unknown_fields` - Error on unrecognized JSON properties\n- `rename_all = \"camelCase\"` - Apply naming convention to all fields",
    "example": "```typescript\n@derive(Deserialize)\n@serde(deny_unknown_fields)\nclass User {\n    id: number;\n\n    @serde(validate(email, maxLength(255)))\n    email: string;\n\n    @serde(default = \"guest\")\n    name: string;\n\n    @serde(validate(positive))\n    age?: number;\n}\n\n// Usage:\nconst result = User.fromStringifiedJSON('{\"id\":1,\"email\":\"test@example.com\"}');\nif (Result.isOk(result)) {\n    const user = result.value;\n} else {\n    console.error(result.error);  // [{ field: \"email\", message: \"must be a valid email\" }]\n}\n```",
    "exampleCode": [
      {
        "lang": "typescript",
        "code": "/** @derive(Deserialize) */\n/** @serde({ deny_unknown_fields: true }) */\nclass User {\n    id: number;\n\n    @serde(validate(email, maxLength(255)))\n    email: string;\n\n    /** @serde({ default: \"guest\" }) */\n    name: string;\n\n    @serde(validate(positive))\n    age?: number;\n}\n\n// Usage:\nconst result = User.fromStringifiedJSON('{\"id\":1,\"email\":\"test@example.com\"}');\nif (Result.isOk(result)) {\n    const user = result.value;\n} else {\n    console.error(result.error);  // [{ field: \"email\", message: \"must be a valid email\" }]\n}",
        "rawCode": "@derive(Deserialize)\n@serde(deny_unknown_fields)\nclass User {\n    id: number;\n\n    @serde(validate(email, maxLength(255)))\n    email: string;\n\n    @serde(default = \"guest\")\n    name: string;\n\n    @serde(validate(positive))\n    age?: number;\n}\n\n// Usage:\nconst result = User.fromStringifiedJSON('{\"id\":1,\"email\":\"test@example.com\"}');\nif (Result.isOk(result)) {\n    const user = result.value;\n} else {\n    console.error(result.error);  // [{ field: \"email\", message: \"must be a valid email\" }]\n}"
      }
    ],
    "title": "Deserialize Macro Implementation",
    "raw": "# Deserialize Macro Implementation\n\nThe `Deserialize` macro generates JSON deserialization methods with **cycle and\nforward-reference support**, plus comprehensive runtime validation. This enables\nsafe parsing of complex JSON structures including circular references.\n\n## Generated Methods\n\n| Type | Generated Methods | Description |\n|------|-------------------|-------------|\n| Class | `static fromStringifiedJSON()`, `static fromObject()`, `static __deserialize()` | Static factory methods |\n| Enum | `EnumName.fromStringifiedJSON()`, `__deserialize()` | Namespace functions |\n| Interface | `InterfaceName.fromStringifiedJSON()`, etc. | Namespace functions |\n| Type Alias | `TypeName.fromStringifiedJSON()`, etc. | Namespace functions |\n\n## Return Type\n\nAll public deserialization methods return `Result<T, Array<{ field: string; message: string }>>`:\n\n- `Result.ok(value)` - Successfully deserialized value\n- `Result.err(errors)` - Array of validation errors with field names and messages\n\n## Cycle/Forward-Reference Support\n\nUses deferred patching to handle references:\n\n1. When encountering `{ \"__ref\": id }`, returns a `PendingRef` marker\n2. Continues deserializing other fields\n3. After all objects are created, `ctx.applyPatches()` resolves all pending references\n\n## Validation\n\nThe macro supports 30+ validators via `@serde(validate(...))`:\n\n### String Validators\n- `email`, `url`, `uuid` - Format validation\n- `minLength(n)`, `maxLength(n)`, `length(n)` - Length constraints\n- `pattern(\"regex\")` - Regular expression matching\n- `nonEmpty`, `trimmed`, `lowercase`, `uppercase` - String properties\n\n### Number Validators\n- `gt(n)`, `gte(n)`, `lt(n)`, `lte(n)`, `between(min, max)` - Range checks\n- `int`, `positive`, `nonNegative`, `finite` - Number properties\n\n### Array Validators\n- `minItems(n)`, `maxItems(n)`, `itemsCount(n)` - Collection size\n\n### Date Validators\n- `validDate`, `afterDate(\"ISO\")`, `beforeDate(\"ISO\")` - Date validation\n\n## Field-Level Options\n\nThe `@serde` decorator supports:\n\n- `skip` / `skip_deserializing` - Exclude field from deserialization\n- `rename = \"jsonKey\"` - Read from different JSON property\n- `default` / `default = expr` - Use default value if missing\n- `flatten` - Read fields from parent object level\n- `validate(...)` - Apply validators\n\n## Container-Level Options\n\n- `deny_unknown_fields` - Error on unrecognized JSON properties\n- `rename_all = \"camelCase\"` - Apply naming convention to all fields\n\n## Union Type Deserialization\n\nUnion types are deserialized based on their member types:\n\n### Literal Unions\nFor unions of literal values (`\"A\" | \"B\" | 123`), the value is validated against\nthe allowed literals directly.\n\n### Primitive Unions\nFor unions containing primitive types (`string | number`), the deserializer uses\n`typeof` checks to validate the value type. No `__type` discriminator is needed.\n\n### Class/Interface Unions\nFor unions of serializable types (`User | Admin`), the deserializer requires a\n`__type` field in the JSON to dispatch to the correct type's `__deserialize` method.\n\n### Generic Type Parameters\nFor generic unions like `type Result<T> = T | Error`, the generic type parameter `T`\nis passed through as-is since its concrete type is only known at the call site.\n\n### Mixed Unions\nMixed unions (e.g., `string | Date | User`) check in order:\n1. Literal values\n2. Primitives (via `typeof`)\n3. Date (via `instanceof` or ISO string parsing)\n4. Serializable types (via `__type` dispatch)\n5. Generic type parameters (pass-through)\n\n## Example\n\n```typescript\n@derive(Deserialize)\n@serde(deny_unknown_fields)\nclass User {\n    id: number;\n\n    @serde(validate(email, maxLength(255)))\n    email: string;\n\n    @serde(default = \"guest\")\n    name: string;\n\n    @serde(validate(positive))\n    age?: number;\n}\n\n// Usage:\nconst result = User.fromStringifiedJSON('{\"id\":1,\"email\":\"test@example.com\"}');\nif (Result.isOk(result)) {\n    const user = result.value;\n} else {\n    console.error(result.error);  // [{ field: \"email\", message: \"must be a valid email\" }]\n}\n```\n\n## Required Imports\n\nThe generated code automatically imports:\n- `Result` from `macroforge/utils`\n- `DeserializeContext`, `DeserializeError`, `PendingRef` from `macroforge/serde`"
  }
}