<script lang="ts">
	import CodeBlock from '$lib/components/ui/CodeBlock.svelte';

	let { data } = $props();
</script>

<svelte:head>
	<title>PositionMapper - Macroforge Documentation</title>
	<meta name="description" content="API reference for the PositionMapper class." />
</svelte:head>

<h1>PositionMapper</h1>

{#if data.version}
	<p class="version-badge">macroforge v{data.version}</p>
{/if}

<p class="lead">
	{data.api.NativePositionMapper?.description ||
		'Maps positions between original source code and macro-expanded code. Essential for accurate error reporting and debugging.'}
</p>

<h2 id="getting-mapper">Getting a Mapper</h2>

<CodeBlock code={`import { NativePlugin, PositionMapper } from "macroforge";

const plugin = new NativePlugin();
const result = plugin.processFile("user.ts", code, { version: "1" });

// Get the mapper for this file
const mapper = plugin.getMapper("user.ts");
if (mapper) {
  // Use the mapper...
}`} lang="typescript" />

<h2 id="methods">Methods</h2>

<h3>isEmpty()</h3>

<p>Check if the mapper has any mappings:</p>

<CodeBlock code={`isEmpty(): boolean`} lang="typescript" />

<h3>originalToExpanded()</h3>

<p>Map a position from original to expanded code:</p>

<CodeBlock code={`originalToExpanded(pos: number): number`} lang="typescript" />

<h3>expandedToOriginal()</h3>

<p>Map a position from expanded to original code:</p>

<CodeBlock code={`expandedToOriginal(pos: number): number | null`} lang="typescript" />

<p>Returns <code>null</code> if the position is in generated code.</p>

<h3>isInGenerated()</h3>

<p>Check if a position is in macro-generated code:</p>

<CodeBlock code={`isInGenerated(pos: number): boolean`} lang="typescript" />

<h3>generatedBy()</h3>

<p>Get the name of the macro that generated code at a position:</p>

<CodeBlock code={`generatedBy(pos: number): string | null`} lang="typescript" />

<h3>mapSpanToOriginal()</h3>

<p>Map a span (range) from expanded to original code:</p>

<CodeBlock code={`mapSpanToOriginal(start: number, length: number): SpanResult | null

interface SpanResult {
  start: number;
  length: number;
}`} lang="typescript" />

<h3>mapSpanToExpanded()</h3>

<p>Map a span from original to expanded code:</p>

<CodeBlock code={`mapSpanToExpanded(start: number, length: number): SpanResult`} lang="typescript" />

<h2 id="example">Example: Error Position Mapping</h2>

<CodeBlock code={`import { NativePlugin } from "macroforge";

const plugin = new NativePlugin();

function mapError(filepath: string, expandedPos: number, message: string) {
  const mapper = plugin.getMapper(filepath);
  if (!mapper) return null;

  // Check if the error is in generated code
  if (mapper.isInGenerated(expandedPos)) {
    const macroName = mapper.generatedBy(expandedPos);
    return {
      message: \`Error in code generated by @derive(\${macroName}): \${message}\`,
      // Find the @derive decorator position
      position: findDecoratorPosition(filepath)
    };
  }

  // Map to original position
  const originalPos = mapper.expandedToOriginal(expandedPos);
  if (originalPos !== null) {
    return {
      message,
      position: originalPos
    };
  }

  return null;
}`} lang="typescript" />

<h2 id="performance">Performance</h2>

<p>
	Position mapping uses binary search with O(log n) complexity:
</p>

<ul>
	<li>Fast lookups even for large files</li>
	<li>Minimal memory overhead</li>
	<li>Thread-safe access</li>
</ul>

<style>
	.version-badge {
		display: inline-block;
		background: var(--color-primary);
		color: white;
		padding: 0.25rem 0.75rem;
		border-radius: 9999px;
		font-size: 0.75rem;
		font-weight: 500;
		margin-bottom: 1rem;
	}
</style>
