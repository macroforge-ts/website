<script lang="ts">
	import CodeBlock from '$lib/components/ui/CodeBlock.svelte';
	import Alert from '$lib/components/ui/Alert.svelte';
</script>

<svelte:head>
	<title>Svelte Preprocessor - Macroforge Documentation</title>
	<meta name="description" content="Set up the Macroforge Svelte preprocessor for macro expansion in Svelte components." />
</svelte:head>

<h1>Svelte Preprocessor</h1>

<p class="lead">
	The Svelte preprocessor expands Macroforge macros in <code>&lt;script&gt;</code> blocks before Svelte compilation, enabling seamless macro usage in Svelte components.
</p>

<h2 id="installation">Installation</h2>

<CodeBlock code={`npm install -D @macroforge/svelte-preprocessor`} lang="bash" />

<h2 id="configuration">Configuration</h2>

<p>Add the preprocessor to your <code>svelte.config.js</code>:</p>

<CodeBlock code={`import adapter from '@sveltejs/adapter-auto';
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';
import { macroforgePreprocess } from '@macroforge/svelte-preprocessor';

/** @type {import('@sveltejs/kit').Config} */
const config = {
  preprocess: [
    macroforgePreprocess(),  // Expand macros FIRST
    vitePreprocess()          // Then handle TypeScript/CSS
  ],

  kit: {
    adapter: adapter()
  }
};

export default config;`} lang="javascript" filename="svelte.config.js" />

<Alert type="warning">
	Always place <code>macroforgePreprocess()</code> <strong>before</strong> other preprocessors like <code>vitePreprocess()</code>. This ensures macros are expanded before TypeScript compilation.
</Alert>

<h2 id="usage">Usage</h2>

<p>Use <code>@derive</code> decorators directly in your Svelte component scripts:</p>

<CodeBlock code={'<script lang="ts">\n  /** @derive(Debug, Clone) */\n  class User {\n    name: string;\n    email: string;\n\n    constructor(name: string, email: string) {\n      this.name = name;\n      this.email = email;\n    }\n  }\n\n  let user = new User("Alice", "alice@example.com");\n  console.log(user.toString());  // Generated by Debug macro\n<\/script>\n\n<p>User: {user.name}</p>'} lang="svelte" filename="UserCard.svelte" />

<h2 id="options">Options</h2>

<CodeBlock code={`macroforgePreprocess({
  // Keep @derive decorators in output (for debugging)
  keepDecorators: false,

  // Process JavaScript files (not just TypeScript)
  processJavaScript: false
})`} lang="typescript" />

<h3>Option Reference</h3>

<table>
	<thead>
		<tr>
			<th>Option</th>
			<th>Type</th>
			<th>Default</th>
			<th>Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>keepDecorators</code></td>
			<td><code>boolean</code></td>
			<td><code>false</code></td>
			<td>Keep decorators in output</td>
		</tr>
		<tr>
			<td><code>processJavaScript</code></td>
			<td><code>boolean</code></td>
			<td><code>false</code></td>
			<td>Process <code>&lt;script&gt;</code> blocks without <code>lang="ts"</code></td>
		</tr>
	</tbody>
</table>

<h2 id="how-it-works">How It Works</h2>

<p>The preprocessor:</p>

<ol>
	<li>Intercepts <code>&lt;script lang="ts"&gt;</code> blocks in <code>.svelte</code> files</li>
	<li>Checks for <code>@derive</code> decorators (skips files without them)</li>
	<li>Expands macros using the native Macroforge binary</li>
	<li>Returns the transformed code for Svelte compilation</li>
</ol>

<Alert type="tip">
	Files without <code>@derive</code> decorators are passed through unchanged with zero overhead.
</Alert>

<h2 id="with-sveltekit">SvelteKit Integration</h2>

<p>For SvelteKit projects, you can use both the preprocessor (for <code>.svelte</code> files) and the Vite plugin (for standalone <code>.ts</code> files):</p>

<CodeBlock code={`// svelte.config.js
import { macroforgePreprocess } from '@macroforge/svelte-preprocessor';
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';

export default {
  preprocess: [
    macroforgePreprocess(),
    vitePreprocess()
  ]
};`} lang="javascript" filename="svelte.config.js" />

<CodeBlock code={`// vite.config.ts
import macroforge from '@macroforge/vite-plugin';
import { sveltekit } from '@sveltejs/kit/vite';
import { defineConfig } from 'vite';

export default defineConfig({
  plugins: [
    macroforge(),  // For .ts files
    sveltekit()
  ]
});`} lang="typescript" filename="vite.config.ts" />

<h2 id="vitest">Using with Vitest</h2>

<p>The preprocessor works seamlessly with Vitest for testing Svelte components:</p>

<CodeBlock code={`// vitest.config.ts
import { defineConfig } from 'vitest/config';
import { sveltekit } from '@sveltejs/kit/vite';
import { svelteTesting } from '@testing-library/svelte/vite';
import macroforge from '@macroforge/vite-plugin';

export default defineConfig({
  plugins: [
    macroforge(),
    sveltekit(),
    svelteTesting()
  ],
  test: {
    environment: 'jsdom',
    include: ['src/**/*.{test,spec}.{js,ts}']
  }
});`} lang="typescript" filename="vitest.config.ts" />

<h2 id="svelte-runes">Svelte 5 Runes Compatibility</h2>

<p>
	The preprocessor is fully compatible with Svelte 5 runes (<code>$state</code>, <code>$derived</code>, <code>$props</code>, etc.). Files using runes but without <code>@derive</code> decorators are skipped entirely.
</p>

<CodeBlock code={'<script lang="ts">\n  // Runes work normally\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n\n  // Macros expand correctly\n  /** @derive(Debug) */\n  class Counter {\n    value: number;\n    constructor(value: number) {\n      this.value = value;\n    }\n  }\n<\/script>'} lang="svelte" />
