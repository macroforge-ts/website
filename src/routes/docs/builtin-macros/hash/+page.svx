<!--
  Generated by node scripts/extract-rust-docs.cjs.
  Do not edit manually â€” edit the Rust module docs instead.
-->

<svelte:head>
	<title>Hash Macro - Macroforge Documentation</title>
	<meta name="description" content="The `Hash` macro generates a `hashCode()` method for computing numeric hash codes.
This is analogous to Rust's `Hash` trait and Java's `hashCode()` method, enabling
objects to be used as keys in hash-based collections." />
</svelte:head>

# Hash

The `Hash` macro generates a `hashCode()` method for computing numeric hash codes.
This is analogous to Rust's `Hash` trait and Java's `hashCode()` method, enabling
objects to be used as keys in hash-based collections.

## Generated Output

| Type | Generated Code | Description |
|------|----------------|-------------|
| Class | `hashCode(): number` | Instance method computing hash from all fields |
| Enum | `hashCodeEnumName(value: EnumName): number` | Standalone function hashing by enum value |
| Interface | `hashCodeInterfaceName(value: InterfaceName): number` | Standalone function computing hash |
| Type Alias | `hashCodeTypeName(value: TypeName): number` | Standalone function computing hash |

## Configuration

The `functionNamingStyle` option in `macroforge.json` controls naming:
- `"prefix"` (default): Prefixes with type name (e.g., `myTypeHashCode`)
- `"suffix"`: Suffixes with type name (e.g., `hashCodeMyType`)
- `"generic"`: Uses TypeScript generics (e.g., `hashCode<T extends MyType>`)
- `"namespace"`: Legacy namespace wrapping

## Hash Algorithm

Uses the standard polynomial rolling hash algorithm:

```text
hash = 17  // Initial seed
for each field:
    hash = (hash * 31 + fieldHash) | 0  // Bitwise OR keeps it 32-bit integer
```

This algorithm is consistent with Java's `Objects.hash()` implementation.

## Type-Specific Hashing

| Type | Hash Strategy |
|------|---------------|
| `number` | Integer: direct value; Float: string hash of decimal |
| `bigint` | String hash of decimal representation |
| `string` | Character-by-character polynomial hash |
| `boolean` | 1231 for true, 1237 for false (Java convention) |
| `Date` | `getTime()` timestamp |
| Arrays | Element-by-element hash combination |
| `Map` | Entry-by-entry key+value hash |
| `Set` | Element-by-element hash |
| Objects | Calls `hashCode()` if available, else JSON string hash |

## Field-Level Options

The `@hash` decorator supports:

- `skip` - Exclude the field from hash calculation

## Example

```typescript before
/** @derive(Hash, PartialEq) */
class User {
    id: number;
    name: string;

    @hash(skip) // Cached value shouldn't affect hash
    cachedScore: number;
}
```

```typescript after
class User {
    id: number;
    name: string;

    // Cached value shouldn't affect hash
    cachedScore: number;

    hashCode(): number {
        let hash = 17;
        hash =
            (hash * 31 +
                (Number.isInteger(this.id)
                    ? this.id | 0
                    : this.id
                          .toString()
                          .split('')
                          .reduce((h, c) => (h * 31 + c.charCodeAt(0)) | 0, 0))) |
            0;
        hash =
            (hash * 31 +
                (this.name ?? '').split('').reduce((h, c) => (h * 31 + c.charCodeAt(0)) | 0, 0)) |
            0;
        return hash;
    }

    equals(other: unknown): boolean {
        if (this === other) return true;
        if (!(other instanceof User)) return false;
        const typedOther = other as User;
        return (
            this.id === typedOther.id &&
            this.name === typedOther.name &&
            this.cachedScore === typedOther.cachedScore
        );
    }
}
```

Generated output:

```typescript
class User {
    id: number;
    name: string;

    // Cached value shouldn't affect hash
    cachedScore: number;

    hashCode(): number {
        let hash = 17;
        hash =
            (hash * 31 +
                (Number.isInteger(this.id)
                    ? this.id | 0
                    : this.id
                          .toString()
                          .split('')
                          .reduce((h, c) => (h * 31 + c.charCodeAt(0)) | 0, 0))) |
            0;
        hash =
            (hash * 31 +
                (this.name ?? '').split('').reduce((h, c) => (h * 31 + c.charCodeAt(0)) | 0, 0)) |
            0;
        return hash;
    }

    equals(other: unknown): boolean {
        if (this === other) return true;
        if (!(other instanceof User)) return false;
        const typedOther = other as User;
        return (
            this.id === typedOther.id &&
            this.name === typedOther.name &&
            this.cachedScore === typedOther.cachedScore
        );
    }
}
```

## Hash Contract

Objects that are equal (`PartialEq`) should produce the same hash code.
When using `@hash(skip)`, ensure the same fields are skipped in both
`Hash` and `PartialEq` to maintain this contract.
