<!--
  Generated by node scripts/extract-rust-docs.cjs.
  Do not edit manually â€” edit the Rust module docs instead.
-->

<svelte:head>
	<title>Ord Macro - Macroforge Documentation</title>
	<meta name="description" content="The `Ord` macro generates a `compareTo()` method for **total ordering** comparison.
This is analogous to Rust's `Ord` trait, enabling objects to be sorted and
compared with a guaranteed ordering relationship." />
</svelte:head>

# Ord

The `Ord` macro generates a `compareTo()` method for **total ordering** comparison.
This is analogous to Rust's `Ord` trait, enabling objects to be sorted and
compared with a guaranteed ordering relationship.

## Generated Output

| Type | Generated Code | Description |
|------|----------------|-------------|
| Class | `compareTo(other): number` | Instance method returning -1, 0, or 1 |
| Enum | `compareEnumName(a: EnumName, b: EnumName): number` | Standalone function comparing enum values |
| Interface | `compareInterfaceName(a: InterfaceName, b: InterfaceName): number` | Standalone function comparing fields |
| Type Alias | `compareTypeName(a: TypeName, b: TypeName): number` | Standalone function with type-appropriate comparison |

## Configuration

The `functionNamingStyle` option in `macroforge.json` controls naming:
- `"prefix"` (default): Prefixes with type name (e.g., `myTypeCompare`)
- `"suffix"`: Suffixes with type name (e.g., `compareMyType`)
- `"generic"`: Uses TypeScript generics (e.g., `compare<T extends MyType>`)
- `"namespace"`: Legacy namespace wrapping

## Return Values

Unlike `PartialOrd`, `Ord` provides **total ordering** - every pair of values
can be compared:

- **-1**: `this` is less than `other`
- **0**: `this` is equal to `other`
- **1**: `this` is greater than `other`

The method **never returns null** - all values must be comparable.

## Comparison Strategy

Fields are compared **lexicographically** in declaration order:

1. Compare first field
2. If not equal, return that result
3. Otherwise, compare next field
4. Continue until a difference is found or all fields are equal

## Type-Specific Comparisons

| Type | Comparison Method |
|------|-------------------|
| `number`/`bigint` | Direct `<` and `>` comparison |
| `string` | `localeCompare()` (clamped to -1, 0, 1) |
| `boolean` | false &lt; true |
| Arrays | Lexicographic element-by-element |
| `Date` | `getTime()` timestamp comparison |
| Objects | Calls `compareTo()` if available, else 0 |

## Field-Level Options

The `@ord` decorator supports:

- `skip` - Exclude the field from ordering comparison

## Example

```typescript
@derive(Ord)
class Version {
    major: number;
    minor: number;
    patch: number;
}

// Generated:
// compareTo(other: Version): number {
//     if (this === other) return 0;
//     const typedOther = other;
//     const cmp0 = this.major < typedOther.major ? -1 : this.major > typedOther.major ? 1 : 0;
//     if (cmp0 !== 0) return cmp0;
//     const cmp1 = this.minor < typedOther.minor ? -1 : ...;
//     if (cmp1 !== 0) return cmp1;
//     const cmp2 = this.patch < typedOther.patch ? -1 : ...;
//     if (cmp2 !== 0) return cmp2;
//     return 0;
// }

// Usage:
versions.sort((a, b) => a.compareTo(b));
```

## Ord vs PartialOrd

- Use **Ord** when all values are comparable (total ordering)
- Use **PartialOrd** when some values may be incomparable (returns `Option<number>`)
