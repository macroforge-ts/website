<!--
  Generated by node scripts/extract-rust-docs.cjs.
  Do not edit manually â€” edit the Rust module docs instead.
-->

<svelte:head>
	<title>Clone Macro - Macroforge Documentation</title>
	<meta name="description" content="The `Clone` macro generates a `clone()` method for deep copying objects.
This is analogous to Rust's `Clone` trait, providing a way to create
independent copies of values." />
</svelte:head>

# Clone

The `Clone` macro generates a `clone()` method for deep copying objects.
This is analogous to Rust's `Clone` trait, providing a way to create
independent copies of values.

## Generated Output

| Type | Generated Code | Description |
|------|----------------|-------------|
| Class | `clone(): ClassName` | Instance method creating a new instance with copied fields |
| Enum | `cloneEnumName(value: EnumName): EnumName` | Standalone function (enums are primitives, returns value as-is) |
| Interface | `cloneInterfaceName(value: InterfaceName): InterfaceName` | Standalone function creating a new object literal |
| Type Alias | `cloneTypeName(value: TypeName): TypeName` | Standalone function with spread copy for objects |

## Cloning Strategy

The generated clone performs a **shallow copy** of all fields:

- **Primitives** (`string`, `number`, `boolean`): Copied by value
- **Objects**: Reference is copied (not deep cloned)
- **Arrays**: Reference is copied (not deep cloned)

For deep cloning of nested objects, those objects should also derive `Clone`
and the caller should clone them explicitly.

## Example

```typescript before
/** @derive(Clone) */
class Point {
    x: number;
    y: number;
}
```

```typescript after
class Point {
    x: number;
    y: number;

    clone(): Point {
        const cloned = Object.create(Object.getPrototypeOf(this));
        cloned.x = this.x;
        cloned.y = this.y;
        return cloned;
    }
}
```

Generated output:

```typescript
class Point {
    x: number;
    y: number;

    clone(): Point {
        const cloned = Object.create(Object.getPrototypeOf(this));
        cloned.x = this.x;
        cloned.y = this.y;
        return cloned;
    }
}
```

## Implementation Notes

- **Classes**: Uses `Object.create(Object.getPrototypeOf(this))` to preserve
  the prototype chain, ensuring `instanceof` checks work correctly
- **Enums**: Simply returns the value (enums are primitives in TypeScript)
- **Interfaces/Type Aliases**: Creates new object literals with spread operator
  for union/tuple types, or field-by-field copy for object types
