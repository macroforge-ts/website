<!--
  Generated by node scripts/extract-rust-docs.cjs.
  Do not edit manually â€” edit the Rust module docs instead.
-->

<svelte:head>
	<title>PartialOrd Macro - Macroforge Documentation</title>
	<meta name="description" content="The `PartialOrd` macro generates a `compareTo()` method for **partial ordering**
comparison. This is analogous to Rust's `PartialOrd` trait, enabling comparison
between values where some pairs may be incomparable." />
</svelte:head>

# PartialOrd

The `PartialOrd` macro generates a `compareTo()` method for **partial ordering**
comparison. This is analogous to Rust's `PartialOrd` trait, enabling comparison
between values where some pairs may be incomparable.

## Generated Output

| Type | Generated Code | Description |
|------|----------------|-------------|
| Class | `compareTo(other): Option<number>` | Instance method with optional result |
| Enum | `partialCompareEnumName(a: EnumName, b: EnumName): Option<number>` | Standalone function returning Option |
| Interface | `partialCompareInterfaceName(a: InterfaceName, b: InterfaceName): Option<number>` | Standalone function with Option |
| Type Alias | `partialCompareTypeName(a: TypeName, b: TypeName): Option<number>` | Standalone function with Option |

## Configuration

The `functionNamingStyle` option in `macroforge.json` controls naming:
- `"prefix"` (default): Prefixes with type name (e.g., `myTypePartialCompare`)
- `"suffix"`: Suffixes with type name (e.g., `partialCompareMyType`)
- `"generic"`: Uses TypeScript generics (e.g., `partialCompare<T extends MyType>`)
- `"namespace"`: Legacy namespace wrapping

## Return Values

Unlike `Ord`, `PartialOrd` returns an `Option<number>` to handle incomparable values:

- **Option.some(-1)**: `this` is less than `other`
- **Option.some(0)**: `this` is equal to `other`
- **Option.some(1)**: `this` is greater than `other`
- **Option.none()**: Values are incomparable

## When to Use PartialOrd vs Ord

- **PartialOrd**: When some values may not be comparable
  - Example: Floating-point NaN values
  - Example: Mixed-type unions
  - Example: Type mismatches between objects

- **Ord**: When all values are guaranteed comparable (total ordering)

## Comparison Strategy

Fields are compared **lexicographically** in declaration order:

1. Compare first field
2. If incomparable, return `Option.none()`
3. If not equal, return that result wrapped in `Option.some()`
4. Otherwise, compare next field
5. Continue until a difference is found or all fields are equal

## Type-Specific Comparisons

| Type | Comparison Method |
|------|-------------------|
| `number`/`bigint` | Direct comparison, returns some() |
| `string` | `localeCompare()` wrapped in some() |
| `boolean` | false &lt; true, wrapped in some() |
| null/undefined | Returns none() for mismatched nullability |
| Arrays | Lexicographic, propagates none() on incomparable elements |
| `Date` | Timestamp comparison, none() if invalid |
| Objects | Unwraps nested Option from compareTo() |

## Field-Level Options

The `@ord` decorator supports:

- `skip` - Exclude the field from ordering comparison

## Example

```typescript before
/** @derive(PartialOrd) */
class Temperature {
    value: number | null; // null represents "unknown"
    unit: string;
}
```

```typescript after
import { Option } from 'macroforge/utils';

class Temperature {
    value: number | null; // null represents "unknown"
    unit: string;

    compareTo(other: unknown): Option<number> {
        if (this === other) return Option.some(0);
        if (!(other instanceof Temperature)) return Option.none();
        const typedOther = other as Temperature;
        const cmp0 = (() => {
            if (typeof (this.value as any)?.compareTo === 'function') {
                const optResult = (this.value as any).compareTo(typedOther.value);
                return Option.isNone(optResult) ? null : optResult.value;
            }
            return this.value === typedOther.value ? 0 : null;
        })();
        if (cmp0 === null) return Option.none();
        if (cmp0 !== 0) return Option.some(cmp0);
        const cmp1 = this.unit.localeCompare(typedOther.unit);
        if (cmp1 === null) return Option.none();
        if (cmp1 !== 0) return Option.some(cmp1);
        return Option.some(0);
    }
}
```

Generated output:

```typescript
class Temperature {
    value: number | null; // null represents "unknown"
    unit: string;

    compareTo(other: unknown): Option<number> {
        if (this === other) return Option.some(0);
        if (!(other instanceof Temperature)) return Option.none();
        const typedOther = other as Temperature;
        const cmp0 = (() => {
            if (typeof (this.value as any)?.compareTo === 'function') {
                const optResult = (this.value as any).compareTo(typedOther.value);
                return Option.isNone(optResult) ? null : optResult.value;
            }
            return this.value === typedOther.value ? 0 : null;
        })();
        if (cmp0 === null) return Option.none();
        if (cmp0 !== 0) return Option.some(cmp0);
        const cmp1 = this.unit.localeCompare(typedOther.unit);
        if (cmp1 === null) return Option.none();
        if (cmp1 !== 0) return Option.some(cmp1);
        return Option.some(0);
    }
}
```

## Required Import

The generated code automatically adds an import for `Option` from `macroforge/utils`.
