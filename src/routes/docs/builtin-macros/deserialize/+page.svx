<!--
  Generated by node scripts/extract-rust-docs.cjs.
  Do not edit manually â€” edit the Rust module docs instead.
-->

<svelte:head>
	<title>Deserialize Macro - Macroforge Documentation</title>
	<meta name="description" content="The `Deserialize` macro generates JSON deserialization methods with **cycle and
forward-reference support**, plus comprehensive runtime validation. This enables
safe parsing of complex JSON structures including circular references." />
</svelte:head>

# Deserialize

The `Deserialize` macro generates JSON deserialization methods with **cycle and
forward-reference support**, plus comprehensive runtime validation. This enables
safe parsing of complex JSON structures including circular references.

## Generated Output

| Type | Generated Code | Description |
|------|----------------|-------------|
| Class | `static fromStringifiedJSON()`, `static fromObject()`, `static __deserialize()` | Static factory methods |
| Enum | `fromStringifiedJSONEnumName(json)`, `__deserializeEnumName(data)`, `isEnumName(value)` | Standalone functions |
| Interface | `fromStringifiedJSONInterfaceName(json)`, `fromObjectInterfaceName(obj)`, etc. | Standalone functions |
| Type Alias | `fromStringifiedJSONTypeName(json)`, `fromObjectTypeName(obj)`, etc. | Standalone functions |

## Configuration

The `functionNamingStyle` option in `macroforge.json` controls naming:
- `"suffix"` (default): Suffixes with type name (e.g., `fromStringifiedJSONMyType`)
- `"prefix"`: Prefixes with type name (e.g., `myTypeFromStringifiedJSON`)
- `"generic"`: Uses TypeScript generics (e.g., `fromStringifiedJSON<T extends MyType>`)
- `"namespace"`: Legacy namespace wrapping

## Return Type

All public deserialization methods return `Result<T, Array<{ field: string; message: string }>>`:

- `Result.ok(value)` - Successfully deserialized value
- `Result.err(errors)` - Array of validation errors with field names and messages

## Cycle/Forward-Reference Support

Uses deferred patching to handle references:

1. When encountering `{ "__ref": id }`, returns a `PendingRef` marker
2. Continues deserializing other fields
3. After all objects are created, `ctx.applyPatches()` resolves all pending references

References only apply to object-shaped, serializable values. The generator avoids probing for
`__ref` on primitive-like fields (including literal unions and `T | null` where `T` is primitive-like),
and it parses `Date` / `Date | null` from ISO strings without treating them as references.

## Validation

The macro supports 30+ validators via `@serde(validate(...))`:

### String Validators
- `email`, `url`, `uuid` - Format validation
- `minLength(n)`, `maxLength(n)`, `length(n)` - Length constraints
- `pattern("regex")` - Regular expression matching
- `nonEmpty`, `trimmed`, `lowercase`, `uppercase` - String properties

### Number Validators
- `gt(n)`, `gte(n)`, `lt(n)`, `lte(n)`, `between(min, max)` - Range checks
- `int`, `positive`, `nonNegative`, `finite` - Number properties

### Array Validators
- `minItems(n)`, `maxItems(n)`, `itemsCount(n)` - Collection size

### Date Validators
- `validDate`, `afterDate("ISO")`, `beforeDate("ISO")` - Date validation

## Field-Level Options

The `@serde` decorator supports:

- `skip` / `skip_deserializing` - Exclude field from deserialization
- `rename = "jsonKey"` - Read from different JSON property
- `default` / `default = expr` - Use default value if missing
- `flatten` - Read fields from parent object level
- `validate(...)` - Apply validators

## Container-Level Options

- `deny_unknown_fields` - Error on unrecognized JSON properties
- `rename_all = "camelCase"` - Apply naming convention to all fields

## Union Type Deserialization

Union types are deserialized based on their member types:

### Literal Unions
For unions of literal values (`"A" | "B" | 123`), the value is validated against
the allowed literals directly.

### Primitive Unions
For unions containing primitive types (`string | number`), the deserializer uses
`typeof` checks to validate the value type. No `__type` discriminator is needed.

### Class/Interface Unions
For unions of serializable types (`User | Admin`), the deserializer requires a
`__type` field in the JSON to dispatch to the correct type's `__deserialize` method.

### Generic Type Parameters
For generic unions like `type Result<T> = T | Error`, the generic type parameter `T`
is passed through as-is since its concrete type is only known at the call site.

### Mixed Unions
Mixed unions (e.g., `string | Date | User`) check in order:
1. Literal values
2. Primitives (via `typeof`)
3. Date (via `instanceof` or ISO string parsing)
4. Serializable types (via `__type` dispatch)
5. Generic type parameters (pass-through)

## Example

```typescript
@derive(Deserialize)
@serde(deny_unknown_fields)
class User {
    id: number;

    @serde(validate(email, maxLength(255)))
    email: string;

    @serde(default = "guest")
    name: string;

    @serde(validate(positive))
    age?: number;
}

// Usage:
const result = User.fromStringifiedJSON('{"id":1,"email":"test@example.com"}');
if (Result.isOk(result)) {
    const user = result.value;
} else {
    console.error(result.error);  // [{ field: "email", message: "must be a valid email" }]
}
```

## Required Imports

The generated code automatically imports:
- `Result` from `macroforge/utils`
- `DeserializeContext`, `DeserializeError`, `PendingRef` from `macroforge/serde`
