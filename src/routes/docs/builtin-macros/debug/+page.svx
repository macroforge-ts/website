<!--
  Generated by node scripts/extract-rust-docs.cjs.
  Do not edit manually â€” edit the Rust module docs instead.
-->

<svelte:head>
	<title>Debug Macro - Macroforge Documentation</title>
	<meta name="description" content="The `Debug` macro generates a human-readable `toString()` method for
TypeScript classes, interfaces, enums, and type aliases." />
</svelte:head>

# Debug

The `Debug` macro generates a human-readable `toString()` method for
TypeScript classes, interfaces, enums, and type aliases.

## Generated Output

**Classes**: Generates an instance method returning a string
like `"ClassName { field1: value1, field2: value2 }"`.

**Enums**: Generates a standalone function `toStringEnumName(value)` that performs
reverse lookup on numeric enums.

**Interfaces**: Generates a standalone function `toStringInterfaceName(value)`.

**Type Aliases**: Generates a standalone function using JSON.stringify for
complex types, or field enumeration for object types.

## Field-Level Options

The `@debug` decorator supports:

- `skip` - Exclude the field from debug output
- `rename = "label"` - Use a custom label instead of the field name

## Example

```typescript before
/** @derive(Debug) */
class User {
    /** @debug({ rename: "id" }) */
    userId: number;

    /** @debug({ skip: true }) */
    password: string;

    email: string;
}
```

```typescript after
class User {
    userId: number;

    password: string;

    email: string;

    toString(): string {
        const parts: string[] = [];
        parts.push('id: ' + this.userId);
        parts.push('email: ' + this.email);
        return 'User { ' + parts.join(', ') + ' }';
    }
}
```

Generated output:

```typescript
class User {
    userId: number;

    password: string;

    email: string;

    toString(): string {
        const parts: string[] = [];
        parts.push('id: ' + this.userId);
        parts.push('email: ' + this.email);
        return 'User { ' + parts.join(', ') + ' }';
    }
}
```
