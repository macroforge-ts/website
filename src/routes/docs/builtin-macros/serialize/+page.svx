<!--
  Generated by node scripts/extract-rust-docs.cjs.
  Do not edit manually â€” edit the Rust module docs instead.
-->

<svelte:head>
	<title>Serialize Macro - Macroforge Documentation</title>
	<meta name="description" content="The `Serialize` macro generates JSON serialization methods with **cycle detection**
and object identity tracking. This enables serialization of complex object graphs
including circular references." />
</svelte:head>

# Serialize

The `Serialize` macro generates JSON serialization methods with **cycle detection**
and object identity tracking. This enables serialization of complex object graphs
including circular references.

## Generated Methods

| Type | Generated Code | Description |
|------|----------------|-------------|
| Class | `serialize()`, `SerializeWithContext(ctx)` | Instance methods |
| Enum | `myEnumSerialize(value)`, `myEnumSerializeWithContext` | Standalone functions |
| Interface | `myInterfaceSerialize(value)`, etc. | Standalone functions |
| Type Alias | `myTypeSerialize(value)`, etc. | Standalone functions |

## Configuration

The `functionNamingStyle` option in `macroforge.json` controls naming:
- `"prefix"` (default): Prefixes with type name (e.g., `myTypeSerialize`)
- `"suffix"`: Suffixes with type name (e.g., `serializeMyType`)
- `"generic"`: Uses TypeScript generics (e.g., `serialize<T extends MyType>`)
- `"namespace"`: Namespace wrapping (e.g., `MyType.serialize`)

## Cycle Detection Protocol

The generated code handles circular references using `__id` and `__ref` markers:

```json
{
    "__type": "User",
    "__id": 1,
    "name": "Alice",
    "friend": { "__ref": 2 }  // Reference to object with __id: 2
}
```

When an object is serialized:
1. Check if it's already been serialized (has an `__id`)
2. If so, return `{ "__ref": existingId }` instead
3. Otherwise, register the object and serialize its fields

## Type-Specific Serialization

| Type | Serialization Strategy |
|------|------------------------|
| Primitives | Direct value |
| `Date` | `toISOString()` |
| Arrays | For primitive-like element types, pass through; for `Date`/`Date | null`, map to ISO strings; otherwise map and call `SerializeWithContext(ctx)` when available |
| `Map<K,V>` | For primitive-like values, `Object.fromEntries(map.entries())`; for `Date`/`Date | null`, convert to ISO strings; otherwise call `SerializeWithContext(ctx)` per value when available |
| `Set<T>` | Convert to array; element handling matches `Array<T>` |
| Nullable | Include `null` explicitly; for primitive-like and `Date` unions the generator avoids runtime `SerializeWithContext` checks |
| Objects | Call `SerializeWithContext(ctx)` if available (to support user-defined implementations) |

Note: the generator specializes some code paths based on the declared TypeScript type to
avoid runtime feature detection on primitives and literal unions.

## Field-Level Options

The `@serde` decorator supports:

- `skip` / `skipSerializing` - Exclude field from serialization
- `rename = "jsonKey"` - Use different JSON property name
- `flatten` - Merge nested object's fields into parent

## Example

```typescript before
/** @derive(Serialize) */
class User {
    id: number;

    /** @serde({ rename: "userName" }) */
    name: string;

    /** @serde({ skipSerializing: true }) */
    password: string;

    /** @serde({ flatten: true }) */
    metadata: UserMetadata;
}
```

```typescript after
import { SerializeContext } from "macroforge/serde";

class User {
    id: number;

    
    name: string;

    
    password: string;

    
    metadata: UserMetadata;
/** macroforge warning: Failed to parse macro output for @macro/derive::Serialize: Failed to parse macro output into class members */
# [doc = "\n                 * Serializes this instance to a JSON string.\n                 * @returns JSON string representation with cycle detection metadata\n                 " ]serialize(): string {const ctx = SerializeContext.create(); return JSON.stringify(this.serializeWithContext(ctx));}# [doc = " @internal " ]SerializeWithContext(ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(this); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(this); const result: Record<string, unknown>= {__type: "User" , __id,}; result["id" ]= this.id; result["userName" ]= this.name; {const __flattened = userMetadataSerializeWithContext(this.metadata, ctx); const {__type: _, __id: __,...rest}= __flattened as any; Object.assign(result, rest);}return result;}}
```

Generated output:

```typescript
import { SerializeContext } from "macroforge/serde";

class User {
    id: number;


    name: string;


    password: string;


    metadata: UserMetadata;
/** macroforge warning: Failed to parse macro output for @macro/derive::Serialize: Failed to parse macro output into class members */
# [doc = "\n                 * Serializes this instance to a JSON string.\n                 * @returns JSON string representation with cycle detection metadata\n                 " ]serialize(): string {const ctx = SerializeContext.create(); return JSON.stringify(this.serializeWithContext(ctx));}# [doc = " @internal " ]SerializeWithContext(ctx: SerializeContext): Record<string, unknown>{const existingId = ctx.getId(this); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(this); const result: Record<string, unknown>= {__type: "User" , __id,}; result["id" ]= this.id; result["userName" ]= this.name; {const __flattened = userMetadataSerializeWithContext(this.metadata, ctx); const {__type: _, __id: __,...rest}= __flattened as any; Object.assign(result, rest);}return result;}}
```

## Required Import

The generated code automatically imports `SerializeContext` from `macroforge/serde`.
