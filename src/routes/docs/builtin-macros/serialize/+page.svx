<!--
  Generated by node scripts/extract-rust-docs.cjs.
  Do not edit manually â€” edit the Rust module docs instead.
-->

<svelte:head>
	<title>Serialize Macro - Macroforge Documentation</title>
	<meta name="description" content="The `Serialize` macro generates JSON serialization methods with **cycle detection**
and object identity tracking. This enables serialization of complex object graphs
including circular references." />
</svelte:head>

# Serialize

The `Serialize` macro generates JSON serialization methods with **cycle detection**
and object identity tracking. This enables serialization of complex object graphs
including circular references.

## Generated Methods

| Type | Generated Code | Description |
|------|----------------|-------------|
| Class | `toStringifiedJSON()`, `toObject()`, `__serialize(ctx)` | Instance methods |
| Enum | `toStringifiedJSONEnumName(value)`, `__serializeEnumName` | Standalone functions |
| Interface | `toStringifiedJSONInterfaceName(value)`, etc. | Standalone functions |
| Type Alias | `toStringifiedJSONTypeName(value)`, etc. | Standalone functions |

## Configuration

The `functionNamingStyle` option in `macroforge.json` controls naming:
- `"prefix"` (default): Prefixes with type name (e.g., `myTypeToStringifiedJSON`)
- `"suffix"`: Suffixes with type name (e.g., `toStringifiedJSONMyType`)
- `"generic"`: Uses TypeScript generics (e.g., `toStringifiedJSON<T extends MyType>`)
- `"namespace"`: Legacy namespace wrapping

## Cycle Detection Protocol

The generated code handles circular references using `__id` and `__ref` markers:

```json
{
    "__type": "User",
    "__id": 1,
    "name": "Alice",
    "friend": { "__ref": 2 }  // Reference to object with __id: 2
}
```

When an object is serialized:
1. Check if it's already been serialized (has an `__id`)
2. If so, return `{ "__ref": existingId }` instead
3. Otherwise, register the object and serialize its fields

## Type-Specific Serialization

| Type | Serialization Strategy |
|------|------------------------|
| Primitives | Direct value |
| `Date` | `toISOString()` |
| Arrays | For primitive-like element types, pass through; for `Date`/`Date | null`, map to ISO strings; otherwise map and call `__serialize(ctx)` when available |
| `Map<K,V>` | For primitive-like values, `Object.fromEntries(map.entries())`; for `Date`/`Date | null`, convert to ISO strings; otherwise call `__serialize(ctx)` per value when available |
| `Set<T>` | Convert to array; element handling matches `Array<T>` |
| Nullable | Include `null` explicitly; for primitive-like and `Date` unions the generator avoids runtime `__serialize` checks |
| Objects | Call `__serialize(ctx)` if available (to support user-defined implementations) |

Note: the generator specializes some code paths based on the declared TypeScript type to
avoid runtime feature detection on primitives and literal unions.

## Field-Level Options

The `@serde` decorator supports:

- `skip` / `skip_serializing` - Exclude field from serialization
- `rename = "jsonKey"` - Use different JSON property name
- `flatten` - Merge nested object's fields into parent

## Example

```typescript before
/** @derive(Serialize) */
class User {
    id: number;

    /** @serde({ rename: "userName" }) */
    name: string;

    /** @serde({ skip_serializing: true }) */
    password: string;

    /** @serde({ flatten: true }) */
    metadata: UserMetadata;
}

// Usage:
const user = new User();
const json = user.toStringifiedJSON();
// => '{"__type":"User","__id":1,"id":1,"userName":"Alice",...}'

const obj = user.toObject();
// => { __type: "User", __id: 1, id: 1, userName: "Alice", ... }
```

```typescript after
import { SerializeContext } from 'macroforge/serde';

class User {
    id: number;

    name: string;

    password: string;

    metadata: UserMetadata;

    toStringifiedJSON(): string {
        const ctx = SerializeContext.create();
        return JSON.stringify(this.__serialize(ctx));
    }

    toObject(): Record<string, unknown> {
        const ctx = SerializeContext.create();
        return this.__serialize(ctx);
    }

    __serialize(ctx: SerializeContext): Record<string, unknown> {
        const existingId = ctx.getId(this);
        if (existingId !== undefined) {
            return {
                __ref: existingId
            };
        }
        const __id = ctx.register(this);
        const result: Record<string, unknown> = {
            __type: 'User',
            __id
        };
        result['id'] = this.id;
        result['userName'] = this.name;
        {
            const __flattened = userMetadata__serialize(this.metadata, ctx);
            const { __type: _, __id: __, ...rest } = __flattened as any;
            Object.assign(result, rest);
        }
        return result;
    }
}

// Usage:
const user = new User();
const json = user.toStringifiedJSON();
// => '{"__type":"User","__id":1,"id":1,"userName":"Alice",...}'

const obj = user.toObject();
// => { __type: "User", __id: 1, id: 1, userName: "Alice", ... }
```

Generated output:

```typescript
import { SerializeContext } from 'macroforge/serde';

class User {
    id: number;

    name: string;

    password: string;

    metadata: UserMetadata;

    toStringifiedJSON(): string {
        const ctx = SerializeContext.create();
        return JSON.stringify(this.__serialize(ctx));
    }

    toObject(): Record<string, unknown> {
        const ctx = SerializeContext.create();
        return this.__serialize(ctx);
    }

    __serialize(ctx: SerializeContext): Record<string, unknown> {
        const existingId = ctx.getId(this);
        if (existingId !== undefined) {
            return {
                __ref: existingId
            };
        }
        const __id = ctx.register(this);
        const result: Record<string, unknown> = {
            __type: 'User',
            __id
        };
        result['id'] = this.id;
        result['userName'] = this.name;
        {
            const __flattened = userMetadata__serialize(this.metadata, ctx);
            const { __type: _, __id: __, ...rest } = __flattened as any;
            Object.assign(result, rest);
        }
        return result;
    }
}

// Usage:
const user = new User();
const json = user.toStringifiedJSON();
// => '{"__type":"User","__id":1,"id":1,"userName":"Alice",...}'

const obj = user.toObject();
// => { __type: "User", __id: 1, id: 1, userName: "Alice", ... }
```

## Required Import

The generated code automatically imports `SerializeContext` from `macroforge/serde`.
