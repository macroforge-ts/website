<!--
  Generated by node scripts/extract-rust-docs.cjs.
  Do not edit manually â€” edit the Rust module docs instead.
-->

<svelte:head>
	<title>Serialize Macro - Macroforge Documentation</title>
	<meta name="description" content="The `Serialize` macro generates JSON serialization methods with **cycle detection**
and object identity tracking. This enables serialization of complex object graphs
including circular references." />
</svelte:head>

# Serialize

The `Serialize` macro generates JSON serialization methods with **cycle detection**
and object identity tracking. This enables serialization of complex object graphs
including circular references.

## Generated Methods

| Type | Generated Code | Description |
|------|----------------|-------------|
| Class | `toStringifiedJSON()`, `toObject()`, `__serialize(ctx)` | Instance methods |
| Enum | `toStringifiedJSONEnumName(value)`, `__serializeEnumName` | Standalone functions |
| Interface | `toStringifiedJSONInterfaceName(value)`, etc. | Standalone functions |
| Type Alias | `toStringifiedJSONTypeName(value)`, etc. | Standalone functions |

## Configuration

The `functionNamingStyle` option in `macroforge.json` controls naming:
- `"prefix"` (default): Prefixes with type name (e.g., `myTypeToStringifiedJSON`)
- `"suffix"`: Suffixes with type name (e.g., `toStringifiedJSONMyType`)
- `"generic"`: Uses TypeScript generics (e.g., `toStringifiedJSON<T extends MyType>`)
- `"namespace"`: Legacy namespace wrapping

## Cycle Detection Protocol

The generated code handles circular references using `__id` and `__ref` markers:

```json
{
    "__type": "User",
    "__id": 1,
    "name": "Alice",
    "friend": { "__ref": 2 }  // Reference to object with __id: 2
}
```

When an object is serialized:
1. Check if it's already been serialized (has an `__id`)
2. If so, return `{ "__ref": existingId }` instead
3. Otherwise, register the object and serialize its fields

## Type-Specific Serialization

| Type | Serialization Strategy |
|------|------------------------|
| Primitives | Direct value |
| `Date` | `toISOString()` |
| Arrays | For primitive-like element types, pass through; for `Date`/`Date | null`, map to ISO strings; otherwise map and call `__serialize(ctx)` when available |
| `Map<K,V>` | For primitive-like values, `Object.fromEntries(map.entries())`; for `Date`/`Date | null`, convert to ISO strings; otherwise call `__serialize(ctx)` per value when available |
| `Set<T>` | Convert to array; element handling matches `Array<T>` |
| Nullable | Include `null` explicitly; for primitive-like and `Date` unions the generator avoids runtime `__serialize` checks |
| Objects | Call `__serialize(ctx)` if available (to support user-defined implementations) |

Note: the generator specializes some code paths based on the declared TypeScript type to
avoid runtime feature detection on primitives and literal unions.

## Field-Level Options

The `@serde` decorator supports:

- `skip` / `skip_serializing` - Exclude field from serialization
- `rename = "jsonKey"` - Use different JSON property name
- `flatten` - Merge nested object's fields into parent

## Example

```typescript
@derive(Serialize)
class User {
    id: number;

    @serde(rename = "userName")
    name: string;

    @serde(skip_serializing)
    password: string;

    @serde(flatten)
    metadata: UserMetadata;
}

// Usage:
const user = new User();
const json = user.toStringifiedJSON();
// => '{"__type":"User","__id":1,"id":1,"userName":"Alice",...}'

const obj = user.toObject();
// => { __type: "User", __id: 1, id: 1, userName: "Alice", ... }
```

## Required Import

The generated code automatically imports `SerializeContext` from `macroforge/serde`.
